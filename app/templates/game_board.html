{% extends "base.html" %}

{% block title %}Insel der Abenteuer{% endblock %}

{% block head_extra %}
<meta name="csrf-token" content="{{ csrf_token() }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
<style>
/* Verbesserte Stile mit modernem Design */
body {
    font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    overflow-x: hidden;
    color: #ffffff;
    height: 100vh;
}

.game-container {
    position: relative;
    width: 75%;
    height: 75vh;
    margin: 50px auto;
    background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
    border-radius: 20px;
    overflow: hidden;
    box-shadow:
        0 25px 60px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(10px);
}

#game-canvas-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
}

#game-canvas {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
    border-radius: 20px;
    transition: filter 0.3s ease;
}

#game-canvas:active {
    cursor: grabbing;
}

#game-canvas:hover {
    filter: brightness(1.05);
}

.game-overlay {
    position: absolute;
    top: 20px;
    left: 20px;
    right: auto;
    bottom: auto;
    z-index: 1000000;
    display: flex;
    flex-direction: column;
    gap: 16px;
    pointer-events: none;
    max-width: 400px;
    opacity: 1;
    visibility: visible;
}

.game-overlay > div {
    pointer-events: auto;
    z-index: 1000001;
    position: relative;
}

.minigame-info-display {
    background: linear-gradient(135deg, 
        rgba(255, 193, 7, 0.95) 0%, 
        rgba(255, 152, 0, 0.9) 100%);
    border-radius: 16px;
    padding: 20px 30px;
    box-shadow: 
        0 10px 30px rgba(0,0,0,0.2), 
        0 1px 8px rgba(0,0,0,0.1),
        inset 0 1px 0 rgba(255,255,255,0.3);
    color: #2c3e50;
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    margin-bottom: 12px;
    max-width: 500px;
    transform: translateY(0);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 1000002;
    display: block;
    visibility: visible;
    opacity: 1;
}

.minigame-info-display:hover {
    transform: translateY(-2px);
    box-shadow: 
        0 15px 40px rgba(0,0,0,0.25), 
        0 5px 15px rgba(0,0,0,0.15),
        inset 0 1px 0 rgba(255,255,255,0.4);
}

.minigame-info-display h4 {
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.4rem;
    font-weight: 700;
    color: #d84315;
    text-shadow: 1px 1px 3px rgba(255,255,255,0.5);
    letter-spacing: -0.5px;
}

.minigame-info-display p {
    margin-bottom: 0;
    font-size: 1rem;
    line-height: 1.5;
    font-weight: 500;
}

.current-team-display {
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.98) 0%, 
        rgba(240, 248, 255, 0.95) 100%);
    border-radius: 16px;
    padding: 18px 28px;
    box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.15),
        0 1px 8px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
    font-weight: 600;
    color: #1565c0;
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.4);
    align-self: flex-start;
    max-width: 320px;
    transition: all 0.3s ease;
}

.current-team-display:hover {
    transform: translateY(-1px);
    box-shadow:
        0 12px 35px rgba(0, 0, 0, 0.18),
        0 2px 10px rgba(0, 0, 0, 0.12),
        inset 0 1px 0 rgba(255, 255, 255, 0.7);
}

.current-team-display h4 {
    margin: 0;
    font-size: 1.3rem;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    letter-spacing: -0.3px;
}

.team-status {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.95) 0%, 
        rgba(245, 250, 255, 0.9) 100%);
    padding: 20px;
    border-radius: 16px;
    box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.15),
        0 1px 8px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.6);
    backdrop-filter: blur(15px);
    border: 1px solid rgba(255, 255, 255, 0.4);
    align-self: flex-start;
    max-width: fit-content;
}

.team-badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px 18px;
    border-radius: 14px;
    color: white;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
    font-weight: 700;
    font-size: 0.95rem;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    transform: scale(1);
    box-shadow:
        0 6px 16px rgba(0, 0, 0, 0.2),
        inset 0 1px 3px rgba(255, 255, 255, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.1);
    animation: gentleFloat 6s ease-in-out infinite;
    border: 2px solid rgba(255, 255, 255, 0.4);
    position: relative;
    overflow: hidden;
}

.team-character-avatar-badge {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    margin-bottom: 6px;
    border: 2px solid rgba(255,255,255,0.8);
    object-fit: cover;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    transition: transform 0.3s ease;
}

.team-badge:hover .team-character-avatar-badge {
    transform: scale(1.1);
}

.team-badge:nth-child(2) { animation-delay: -1.2s; }
.team-badge:nth-child(3) { animation-delay: -2.4s; }
.team-badge:nth-child(4) { animation-delay: -3.6s; }

@keyframes gentleFloat {
    0% { transform: translateY(0px) scale(1); }
    33% { transform: translateY(-4px) scale(1.01); }
    66% { transform: translateY(-2px) scale(1.005); }
    100% { transform: translateY(0px) scale(1); }
}

.team-badge:hover {
    transform: scale(1.08) translateY(-4px);
    box-shadow:
        0 15px 25px rgba(0, 0, 0, 0.35),
        inset 0 2px 5px rgba(255, 255, 255, 0.4),
        0 0 0 2px rgba(255, 255, 255, 0.2);
}

.team-badge.active-team {
    border: 3px solid #ffd700;
    transform: scale(1.15) translateY(-5px);
    box-shadow:
        0 0 30px rgba(255, 215, 0, 0.8),
        0 15px 30px rgba(0, 0, 0, 0.4),
        inset 0 2px 8px rgba(255, 255, 255, 0.5);
    animation: activeGlow 3s infinite, gentleFloat 6s ease-in-out infinite;
    z-index: 10;
    position: relative;
}

@keyframes activeGlow {
    0% {
        box-shadow:
            0 0 30px rgba(255, 215, 0, 0.8),
            0 15px 30px rgba(0, 0, 0, 0.4),
            inset 0 2px 8px rgba(255, 255, 255, 0.5);
    }
    50% {
        box-shadow:
            0 0 40px rgba(255, 215, 0, 1),
            0 18px 35px rgba(0, 0, 0, 0.5),
            inset 0 3px 12px rgba(255, 255, 255, 0.6);
    }
    100% {
        box-shadow:
            0 0 30px rgba(255, 215, 0, 0.8),
            0 15px 30px rgba(0, 0, 0, 0.4),
            inset 0 2px 8px rgba(255, 255, 255, 0.5);
    }
}

.team-badge::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
        transparent, 
        rgba(255, 255, 255, 0.4), 
        transparent);
    transition: left 0.6s ease;
    z-index: 1;
}

.team-badge:hover::before {
    left: 100%;
}

.team-name { 
    font-size: 0.95rem; 
    letter-spacing: 0.5px; 
    position: relative;
    z-index: 2;
}

.team-position { 
    font-size: 0.85rem; 
    opacity: 0.95; 
    margin-top: 3px;
    position: relative;
    z-index: 2;
}

.team-bonus {
    position: relative;
    z-index: 2;
}

.dice-result-display {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(135deg, 
        rgba(255, 215, 0, 0.98) 0%, 
        rgba(255, 193, 7, 0.95) 50%,
        rgba(255, 152, 0, 0.9) 100%);
    border-radius: 24px;
    width: 200px;
    min-height: 160px;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 
        0 0 60px rgba(255, 215, 0, 0.9), 
        0 20px 50px rgba(0, 0, 0, 0.4), 
        inset 0 4px 20px rgba(255, 255, 255, 0.5);
    z-index: 99999999;
    opacity: 0;
    transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    border: 3px solid rgba(255, 255, 255, 0.8);
    text-align: center;
    backdrop-filter: blur(10px);
}

.dice-result-display.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
}

.dice-result-part {
    font-size: 1.1rem;
    color: #5d4037;
    margin-bottom: 6px;
    font-weight: 600;
}

.dice-result-part span {
    font-weight: bold;
}

.dice-result-total {
    font-size: 1.2rem;
    font-weight: bold;
    color: #bf360c;
    margin-top: 8px;
}

.dice-result-number {
    font-size: 3.5rem;
    font-weight: 900;
    color: #1a237e;
    text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.3);
    line-height: 1;
    margin-left: 5px;
    background: linear-gradient(45deg, #1a237e, #3f51b5);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.dice-result-text {
    font-size: 1.1rem;
    color: #3f51b5;
    font-weight: 700;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
    margin-top: 4px;
}

kbd {
    background: linear-gradient(145deg, #263238, #37474f);
    color: white;
    padding: 6px 12px;
    border-radius: 10px;
    font-size: 0.9em;
    box-shadow: 
        0 4px 8px rgba(0, 0, 0, 0.3), 
        inset 0 1px 2px rgba(255, 255, 255, 0.2);
    border: 1px solid #1a252f;
    font-weight: 600;
}

.status-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, 
        rgba(26, 35, 47, 0.96) 0%, 
        rgba(44, 62, 80, 0.94) 100%);
    color: white;
    padding: 25px 45px;
    border-radius: 18px;
    font-size: 1.4rem;
    font-weight: 700;
    z-index: 99999999;
    backdrop-filter: blur(15px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    box-shadow: 
        0 15px 40px rgba(0, 0, 0, 0.5), 
        inset 0 1px 3px rgba(255, 255, 255, 0.1);
    animation: statusMessageAnim 3.5s ease-in-out forwards;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    text-align: center;
    max-width: 80%;
}

.status-message.status-error {
    background: linear-gradient(135deg, 
        rgba(200, 50, 50, 0.96) 0%, 
        rgba(180, 30, 30, 0.94) 100%);
}

.status-message.status-success {
    background: linear-gradient(135deg, 
        rgba(50, 180, 50, 0.96) 0%, 
        rgba(30, 160, 30, 0.94) 100%);
}

@keyframes statusMessageAnim {
    0% { 
        opacity: 0; 
        transform: translate(-50%, -70%) scale(0.8); 
    }
    15% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.05); 
    }
    20% { 
        transform: translate(-50%, -50%) scale(1); 
    }
    85% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1); 
    }
    100% { 
        opacity: 0; 
        transform: translate(-50%, -30%) scale(0.8); 
    }
}

@media (max-width: 768px) {
    .game-container {
        width: 95%;
        height: 80vh;
        margin: 20px auto;
        border-radius: 15px;
    }
    
    #game-canvas-container {
        border-radius: 15px;
    }
    
    .game-overlay {
        max-width: 300px;
        gap: 12px;
        top: 15px;
        left: 15px;
    }
    
    .minigame-info-display {
        padding: 15px 20px;
    }
    
    .minigame-info-display h4 {
        font-size: 1.2rem;
    }
    
    .minigame-info-display p {
        font-size: 0.9rem;
    }
    
    .current-team-display {
        padding: 12px 18px;
    }
    
    .current-team-display h4 {
        font-size: 1.1rem;
    }
    
    .team-status {
        flex-direction: column;
        padding: 15px;
        align-items: flex-start;
    }
    
    .team-badge {
        padding: 10px 12px;
        font-size: 0.85rem;
        margin-bottom: 8px;
    }
    
    .dice-result-display {
        width: 170px;
        min-height: 140px;
        padding: 15px;
    }
    
    .dice-result-number {
        font-size: 2.8rem;
    }
    
    .dice-result-text {
        font-size: 1rem;
    }
    
    /* Mobile Vollbild */
    :fullscreen .game-container,
    :-webkit-full-screen .game-container,
    :-moz-full-screen .game-container {
        width: 100vw !important;
        height: 100vh !important;
        margin: 0 !important;
        border-radius: 0 !important;
    }
}

.game-overlay::after {
    content: 'Steuerung: M = Freie Kamera • C = Kameramodus • F = Vollbild';
    position: absolute;
    bottom: -40px;
    left: 0;
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.9);
    background: linear-gradient(135deg, 
        rgba(0, 0, 0, 0.4) 0%, 
        rgba(0, 0, 0, 0.3) 100%);
    padding: 8px 15px;
    border-radius: 10px;
    backdrop-filter: blur(8px);
    pointer-events: none;
    border: 1px solid rgba(255, 255, 255, 0.2);
    font-weight: 500;
}

/* Vollbild-spezifische Styles - Canvas Container als Fullscreen Element */
#game-canvas-container:fullscreen,
#game-canvas-container:-webkit-full-screen,
#game-canvas-container:-moz-full-screen {
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
    background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%) !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 999999 !important;
}

#game-canvas-container:fullscreen #game-canvas,
#game-canvas-container:-webkit-full-screen #game-canvas,
#game-canvas-container:-moz-full-screen #game-canvas {
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
}

#game-canvas-container:fullscreen .game-overlay,
#game-canvas-container:-webkit-full-screen .game-overlay,
#game-canvas-container:-moz-full-screen .game-overlay {
    position: absolute !important;
    top: 20px !important;
    left: 20px !important;
    right: auto !important;
    bottom: auto !important;
    z-index: 999999999 !important;
    display: flex !important;
    flex-direction: column !important;
    gap: 16px !important;
    max-width: 400px !important;
    opacity: 1 !important;
    visibility: visible !important;
}

#game-canvas-container:fullscreen .game-overlay > div,
#game-canvas-container:-webkit-full-screen .game-overlay > div,
#game-canvas-container:-moz-full-screen .game-overlay > div {
    display: block !important;
    opacity: 1 !important;
    visibility: visible !important;
    z-index: 999999999 !important;
}

#game-canvas-container:fullscreen .current-team-display,
#game-canvas-container:-webkit-full-screen .current-team-display,
#game-canvas-container:-moz-full-screen .current-team-display,
#game-canvas-container:fullscreen .team-status,
#game-canvas-container:-webkit-full-screen .team-status,
#game-canvas-container:-moz-full-screen .team-status {
    display: flex !important;
    opacity: 1 !important;
    visibility: visible !important;
}

/* Legacy Fullscreen Styles als Fallback */
:fullscreen,
:-webkit-full-screen,
:-moz-full-screen {
    background: #000 !important;
    margin: 0 !important;
    padding: 0 !important;
}

:fullscreen body,
:-webkit-full-screen body,
:-moz-full-screen body {
    margin: 0 !important;
    padding: 0 !important;
    overflow: hidden !important;
}

:fullscreen .game-container,
:-webkit-full-screen .game-container,
:-moz-full-screen .game-container {
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
    margin: 0 !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    z-index: 999999 !important;
    background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%) !important;
}

:fullscreen #game-canvas-container,
:-webkit-full-screen #game-canvas-container,
:-moz-full-screen #game-canvas-container {
    border-radius: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
}

:fullscreen #game-canvas,
:-webkit-full-screen #game-canvas,
:-moz-full-screen #game-canvas {
    border-radius: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
}

:fullscreen .game-overlay,
:-webkit-full-screen .game-overlay,
:-moz-full-screen .game-overlay {
    position: absolute !important;
    top: 20px !important;
    left: 20px !important;
    right: auto !important;
    bottom: auto !important;
    z-index: 999999999 !important;
    display: flex !important;
    max-width: 400px !important;
}

/* Vollbild: Alles andere ausblenden */
:fullscreen nav,
:-webkit-full-screen nav,
:-moz-full-screen nav,
:fullscreen .navbar,
:-webkit-full-screen .navbar,
:-moz-full-screen .navbar,
:fullscreen footer,
:-webkit-full-screen footer,
:-moz-full-screen footer {
    display: none !important;
}

/* Vollbild: Body-Container ausblenden */
:fullscreen > *:not(.game-container),
:-webkit-full-screen > *:not(.game-container),
:-moz-full-screen > *:not(.game-container) {
    display: none !important;
}

/* Neue CSS-Klassen für verbesserte Effekte */
@keyframes shimmer {
    0% { background-position: -200px 0; }
    100% { background-position: 200px 0; }
}

.enhanced-glow {
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
}

.smooth-transition {
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Particle-Effekt für Hintergrund */
.game-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
        radial-gradient(2px 2px at 20px 30px, rgba(255,255,255,0.3), transparent),
        radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.2), transparent),
        radial-gradient(1px 1px at 90px 40px, rgba(255,255,255,0.4), transparent),
        radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.3), transparent),
        radial-gradient(2px 2px at 160px 30px, rgba(255,255,255,0.2), transparent);
    background-repeat: repeat;
    background-size: 200px 100px;
    animation: sparkle 15s linear infinite;
    pointer-events: none;
    z-index: 1;
}

@keyframes sparkle {
    0% { transform: translateX(0); }
    100% { transform: translateX(200px); }
}

#game-canvas-container {
    position: relative;
    z-index: 2;
}
</style>
{% endblock %}

{% block content %}

<!-- WICHTIG: Alle UI-Elemente DIREKT im Canvas-Container -->
<div class="game-container">
    <div id="game-canvas-container">
        <canvas id="game-canvas"></canvas>

        <!-- UI direkt auf dem Canvas -->
        <div class="game-overlay">
            <div id="minigame-info-display" class="minigame-info-display" style="display: none;">
                <h4 id="minigame-name"></h4>
                <p id="minigame-description"></p>
            </div>

            <div class="current-team-display">
                <h4>Am Zug: <span id="current-team">-</span></h4>
            </div>

            <div class="team-status">
                {% if teams %}
                    {% for team in teams %}
                    <div class="team-badge" id="team-badge-{{ team.id }}" style="background-color: {{ team_colors[loop.index0 % team_colors|length] }};">
                        {% if team.character and team.character.image_file %}
                            <img src="{{ url_for('static', filename='images/characters/' + team.character.image_file) }}" alt="{{ team.character.name }}" class="team-character-avatar-badge">
                        {% endif %}
                        <span class="team-name">{{ team.name }}</span>
                        <span class="team-position">Position: {{ team.current_position if team.current_position is not none else 0 }}</span>
                        <span class="team-bonus" style="font-size: 0.75em; opacity: 0.9;">
                            Bonus:
                            {% if team.bonus_dice_sides == 6 %}1-6
                            {% elif team.bonus_dice_sides == 4 %}1-4
                            {% elif team.bonus_dice_sides == 2 %}1-2
                            {% else %}0
                            {% endif %}
                        </span>
                    </div>
                    {% endfor %}
                {% else %}
                    {% if is_admin %}
                        <p class="text-muted p-2">Noch keine Teams angelegt. Bitte im <a href='{{ url_for('admin.admin_dashboard') }}'>Admin Dashboard</a> Teams erstellen, um das Spielbrett zu sehen.</p>
                    {% else %}
                        <p class="text-muted p-2">Warte auf Spieler oder starte ein neues Spiel.</p>
                    {% endif %}
                {% endif %}
            </div>

            <!-- Würfelergebnis-Anzeige auch direkt hier -->
            <div id="dice-result-display" class="dice-result-display">
                <div id="dice-result-standard" class="dice-result-part">Standard: <span>-</span></div>
                <div id="dice-result-bonus" class="dice-result-part" style="display: none;">Bonus: <span>-</span></div>
                <div class="dice-result-total">Gesamt: <span class="dice-result-number">0</span></div>
                <div class="dice-result-text">Felder</div>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
{{ super() }}
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script src="{{ url_for('static', filename='js/characters/defaultCharacter.js') }}"></script>

<script>
// Verbesserte Spielbrett-Konfiguration
const BOARD_CONFIG = {
    fieldTypes: { 
        start: { color: 0x4FC3F7, emission: 0x003366, name: 'Start' }, 
        normal: { color: 0x81C784, emission: 0x002233, name: 'Normales Feld' }, 
        bonus: { color: 0xFFD54F, emission: 0x554400, name: 'Bonusfeld' }, 
        chance: { color: 0xAED581, emission: 0x335500, name: 'Ereignisfeld' }, 
        trap: { color: 0xE57373, emission: 0x550000, name: 'Falle' }, 
        minigame: { color: 0xBA68C8, emission: 0x550055, name: 'Minispiel' }, 
        goal: { color: 0xFFB74D, emission: 0x553300, name: 'Ziel' } 
    },
    fieldSize: 1.0,
    fieldHeight: 0.3,
    fieldRadius: 0.6,
    pathWidth: 3.0,
    pathSegmentBaseDepth: 0.3,
    pathColor: 0xE8DCC6,
    pathBorderColor: 0xD7CCC8,
    characterElevation: 0.5,
    characterSize: 0.65,
    mountainHeight: 20,
    mountainBaseRadius: 22,
    mountainTopRadius: 4,
    spiralHeight: 18,
    spiralStartRadius: 25,
    spiralLoops: 2.8,
    pathDepth: 4.5,
    chamberSize: 8,
    // Verbesserte Kamera-Offsets für cinematische Ansichten
    cameraFollowOffset: new THREE.Vector3(0, 15, 25),
    cameraFrontOffset: new THREE.Vector3(0, 10, -15),
    cameraSideOffset: new THREE.Vector3(20, 12, 8),
    cameraTopOffset: new THREE.Vector3(0, 30, 5)
};

const islandSurfaceY = 1.0; // Angepasst an neue Inselposition

const GAME_STATE = {
    isAnimating: false,
    isDiceRolling: false,
    isCharacterMoving: false,
    freeCameraMode: false,
    isFullscreen: false,
    isAnimatingCamera: false,
    cameraMode: 'overview', // 'overview', 'follow', 'cinematic'
    currentServerTeamTurnId: null,
    diceRollOrderFromServer: [],
    cinematicMode: false,
    cinematicTimer: null
};

let localTeams = [
    {% for team in teams %}
    {
        id: {{ team.id }},
        name: "{{ team.name | e }}",
        position: {{ team.current_position if team.current_position is not none else 0 }},
        color: "{{ team_colors[loop.index0 % team_colors|length] }}",
        character_info: {% if team.character and team.character.name and team.character.js_file %}
        {
            name: "{{ team.character.name | e }}",
            js_file: "{{ team.character.js_file | e }}",
            image_file: "{{ team.character.image_file | default('') | e }}"
        }
        {% else %}
        {
            name: "Default",
            js_file: "js/characters/defaultCharacter.js",
            image_file: "default.png"
        }
        {% endif %},
        bonus_dice_sides: {{ team.bonus_dice_sides if team.bonus_dice_sides else 0 }},
        minigame_placement: {{ team.minigame_placement if team.minigame_placement else 'null' }}
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];

let currentMinigameName = "{{ active_session.current_minigame_name | e if active_session else '' }}";
let currentMinigameDescription = "{{ active_session.current_minigame_description | e if active_session else '' }}";
let currentGamePhase = "{{ active_session.current_phase | e if active_session else 'UNKNOWN' }}";

const isAdmin = {{ is_admin|tojson }};

class WiiPartyIsland {
    constructor(canvasId) {
        console.log("[WiiPartyIsland] Constructor: Start");
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error("[WiiPartyIsland] FEHLER: Canvas-Element mit ID '" + canvasId + "' nicht gefunden!");
            return;
        }

        this.updateCanvasSize = this.updateCanvasSize.bind(this);
        this.animate = this.animate.bind(this);
        this.setupEventListeners = this.setupEventListeners.bind(this);

        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(55, this.canvas.clientWidth / Math.max(1, this.canvas.clientHeight), 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            canvas: this.canvas, 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });

        // Verbesserte Renderer-Einstellungen
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.1;
        this.renderer.physicallyCorrectLights = true;

        this.updateCanvasSize();

        // Verbesserte Kamera-Startposition
        this.camera.position.set(0, BOARD_CONFIG.mountainHeight * 1.4, BOARD_CONFIG.spiralStartRadius * 2);
        this.camera.lookAt(0, BOARD_CONFIG.mountainHeight * 0.4, 0);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 15;
        this.controls.maxDistance = 120;
        this.controls.maxPolarAngle = Math.PI / 1.8;
        this.controls.target.set(0, BOARD_CONFIG.mountainHeight * 0.4, 0);
        this.controls.enabled = false;

        // Cinematic camera system
        this.cinematicCameras = [];
        this.currentCinematicIndex = 0;
        this.cinematicTransitionDuration = 3000;

        this.pathPoints = [];
        this.boardFields = [];
        this.miiCharacters = {};
        this.interactiveDice = null;
        this.island = null;
        this.mountainMesh = null;
        this.chamberDoor = null;
        this.water = null;
        this.clouds = [];
        this.birds = [];
        this.particles = [];
        this.isFollowingCharacter = false;
        this.followTarget = null;
        this.characterCreationFunctions = {};
        this.activeMovementAnimation = null;
        this.lastCameraUpdate = 0;

        console.log("[WiiPartyIsland] Constructor: Basisinitialisierung abgeschlossen, rufe init()");
        this.init();
    }

    updateCanvasSize() {
        const container = document.getElementById('game-canvas-container');
        if (!container) return;
        
        let width, height;
        
        // Prüfe ob im Vollbildmodus
        if (GAME_STATE.isFullscreen || 
            document.fullscreenElement === container ||
            document.webkitFullscreenElement === container ||
            document.mozFullScreenElement === container) {
            // Vollbild: Komplette Bildschirmgröße
            width = window.innerWidth;
            height = window.innerHeight;
        } else {
            // Normal: Container-Größe
            const rect = container.getBoundingClientRect();
            width = Math.max(1, rect.width);
            height = Math.max(1, rect.height);
        }
        
        this.renderer.setSize(width, height, false);
        
        if (this.camera) {
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
        }
    }

    async init() {
        this.setupAdvancedLighting();
        this.createAdvancedOcean();
        this.createEnhancedIslandAndMountain();
        this.createSpiralPath();
        this.createEnhancedVegetation();
        this.createTreasureChamber();
        this.setupCinematicCameras();

        if (localTeams && localTeams.length > 0) {
            await this.createMiiCharacters();
        }

        this.createAdvancedEnvironmentalDetails();
        this.createInteractiveDice();
        this.setupEventListeners();
        this.animate();
        this.updateMinigameDisplay();
        this.fetchBoardStatusAndUpdate();
        setInterval(() => this.fetchBoardStatusAndUpdate(), 3500);
        
        // Starte mit einer cinematischen Kamerafahrt
        setTimeout(() => this.startCinematicIntro(), 1000);
        
        console.log("[WiiPartyIsland] init(): Beendet");
    }

    setupAdvancedLighting() {
        // Verbesserte Beleuchtung für cinematisches Aussehen
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        // Hauptlicht (Sonne)
        const sunLight = new THREE.DirectionalLight(0xffeaa7, 1.8);
        sunLight.position.set(100, 150, 80);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 400;
        const shadowCamSize = 120;
        sunLight.shadow.camera.left = -shadowCamSize;
        sunLight.shadow.camera.right = shadowCamSize;
        sunLight.shadow.camera.top = shadowCamSize;
        sunLight.shadow.camera.bottom = -shadowCamSize;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.radius = 8;
        this.scene.add(sunLight);

        // Rim Light für dramatischen Effekt
        const rimLight = new THREE.DirectionalLight(0x74b9ff, 0.8);
        rimLight.position.set(-80, 100, -60);
        this.scene.add(rimLight);

        // Atmosphärisches Fülllicht
        const fillLight = new THREE.DirectionalLight(0xfdcb6e, 0.4);
        fillLight.position.set(40, 80, 120);
        this.scene.add(fillLight);

        // Verbesserte Szenen-Atmosphäre
        this.scene.background = new THREE.Color(0x87ceeb);
        this.scene.fog = new THREE.Fog(0x87ceeb, 120, 350);
    }

    createAdvancedOcean() {
        const oceanRadius = 180;
        const waterGeometry = new THREE.PlaneGeometry(oceanRadius * 2, oceanRadius * 2, 128, 128);
        
        // Erweiterte Wellenanimation
        const positions = waterGeometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const z = positions[i + 2];
            positions[i + 1] = Math.sin(x * 0.03 + z * 0.02) * 0.3 + 
                              Math.cos(z * 0.04 + x * 0.01) * 0.2 +
                              Math.sin(x * 0.07) * 0.1;
        }
        waterGeometry.attributes.position.needsUpdate = true;
        waterGeometry.computeVertexNormals();

        const waterMaterial = new THREE.MeshPhongMaterial({
            color: 0x006994,
            specular: 0xffffff,
            shininess: 100,
            transparent: true,
            opacity: 0.9,
            reflectivity: 0.3
        });

        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -1.5; // Tiefer positioniert für bessere Optik
        water.receiveShadow = true;
        this.scene.add(water);

        water.userData = {
            animation: time => {
                const positions = water.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i + 2];
                    positions[i + 1] = Math.sin(x * 0.03 + z * 0.02 + time * 0.4) * 0.3 +
                                     Math.cos(z * 0.04 + x * 0.01 + time * 0.6) * 0.2 +
                                     Math.sin(x * 0.07 + time * 1.2) * 0.1;
                }
                water.geometry.attributes.position.needsUpdate = true;
            }
        };
        this.water = water;
    }

    createEnhancedIslandAndMountain() {
        // Kleinere Insel ohne herausragende Ecken
        const islandGeometry = new THREE.CylinderGeometry(
            BOARD_CONFIG.mountainBaseRadius + 2, 
            BOARD_CONFIG.mountainBaseRadius + 3, 
            3.5, 
            64, 
            8, 
            false
        );
        
        const islandMaterial = new THREE.MeshPhongMaterial({
            map: this.createEnhancedIslandTexture(),
            shininess: 15,
            specular: 0x222222
        });
        
        this.island = new THREE.Mesh(islandGeometry, islandMaterial);
        this.island.position.y = -1; // Tiefer positioniert
        this.island.receiveShadow = true;
        this.island.castShadow = true;
        this.scene.add(this.island);
        
        this.createEnhancedIslandVegetation();
        this.createMountainWithPath(true);
    }

    createEnhancedIslandTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        // Gradient-Basis
        const gradient = ctx.createRadialGradient(512, 512, 0, 512, 512, 512);
        gradient.addColorStop(0, '#F4E4BC');
        gradient.addColorStop(0.6, '#E8D5A3');
        gradient.addColorStop(1, '#D4C19C');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1024, 1024);

        // Detaillierte Grasflecken
        for (let i = 0; i < 5000; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = Math.random() * 25 + 8;
            const grassShade = Math.floor(Math.random() * 40) + 85;
            const alpha = Math.random() * 0.7 + 0.3;
            ctx.fillStyle = `rgba(${Math.floor(grassShade * 0.4)}, ${grassShade}, ${Math.floor(grassShade * 0.2)}, ${alpha})`;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Steinformationen
        for (let i = 0; i < 150; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const size = Math.random() * 12 + 6;
            const rockShade = Math.floor(Math.random() * 30) + 120;
            ctx.fillStyle = `rgba(${rockShade}, ${rockShade}, ${rockShade - 20}, 0.8)`;
            ctx.fillRect(x, y, size, size);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2, 2);
        return texture;
    }

    createEnhancedIslandVegetation() {
        const baseIslandTopY = islandSurfaceY - 1; // Angepasst an neue Inselposition
        const vegGeometry = new THREE.CylinderGeometry(
            BOARD_CONFIG.mountainBaseRadius + 1, 
            BOARD_CONFIG.mountainBaseRadius + 1, 
            0.4, 
            64
        );
        
        const vegMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x7CB342 
        });
        
        const vegetation = new THREE.Mesh(vegGeometry, vegMaterial);
        vegetation.position.y = baseIslandTopY + 0.2;
        vegetation.receiveShadow = true;
        this.scene.add(vegetation);
    }

    setupCinematicCameras() {
        // Definiere verschiedene cinematische Kamerapositionen
        this.cinematicCameras = [
            {
                position: new THREE.Vector3(50, 30, 50),
                target: new THREE.Vector3(0, 15, 0),
                name: "Aerial Overview"
            },
            {
                position: new THREE.Vector3(-40, 25, 30),
                target: new THREE.Vector3(0, 10, 0),
                name: "Side Dramatic"
            },
            {
                position: new THREE.Vector3(0, 45, 80),
                target: new THREE.Vector3(0, 20, 0),
                name: "High Overview"
            },
            {
                position: new THREE.Vector3(60, 20, -20),
                target: new THREE.Vector3(0, 15, 0),
                name: "Oblique View"
            }
        ];
    }

    startCinematicIntro() {
        if (GAME_STATE.freeCameraMode) return;
        
        GAME_STATE.cinematicMode = true;
        this.currentCinematicIndex = 0;
        this.cycleCinematicCamera();
        
        // Auto-cycling für 15 Sekunden
        GAME_STATE.cinematicTimer = setTimeout(() => {
            GAME_STATE.cinematicMode = false;
            this.setOverviewCamera(false);
        }, 15000);
    }

    cycleCinematicCamera() {
        if (!GAME_STATE.cinematicMode || GAME_STATE.freeCameraMode) return;
        
        const camera = this.cinematicCameras[this.currentCinematicIndex];
        this.animateCameraToPosition(camera.position, camera.target, this.cinematicTransitionDuration, () => {
            if (GAME_STATE.cinematicMode) {
                setTimeout(() => {
                    this.currentCinematicIndex = (this.currentCinematicIndex + 1) % this.cinematicCameras.length;
                    this.cycleCinematicCamera();
                }, 2000);
            }
        });
    }

    createMountainWithPath(enhanced = true) {
        this.calculatePathPoints();
        const detail = enhanced ? 256 : 128;
        const mountainGeometry = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const uvs = [];
        const flatTopRadius = BOARD_CONFIG.mountainTopRadius * 0.85;
        const mountainFootY = islandSurfaceY;

        for (let i = 0; i <= detail; i++) {
            for (let j = 0; j <= detail; j++) {
                const x = (i / detail - 0.5) * BOARD_CONFIG.mountainBaseRadius * 2.5;
                const z = (j / detail - 0.5) * BOARD_CONFIG.mountainBaseRadius * 2.5;
                const distance = Math.sqrt(x * x + z * z);
                let y_shape = 0;

                if (distance <= BOARD_CONFIG.mountainBaseRadius) {
                    if (distance <= flatTopRadius) {
                        y_shape = BOARD_CONFIG.mountainHeight + (Math.random() * 0.1 - 0.05);
                    } else {
                        const progress = (distance - flatTopRadius) / (BOARD_CONFIG.mountainBaseRadius - flatTopRadius);
                        const smoothProgress = 1 - Math.pow(progress, enhanced ? 1.3 : 1.5);
                        y_shape = BOARD_CONFIG.mountainHeight * smoothProgress;
                        
                        // Erweiterte Geländedeformation
                        y_shape += (Math.sin(x * 0.6 + z * 0.4) * Math.cos(z * 0.7 - x * 0.5)) * 0.4 * (1 - smoothProgress);
                        y_shape += (Math.sin(x * 1.2) * Math.cos(z * 1.3)) * 0.15 * (1 - smoothProgress);
                    }
                    
                    const pathInfluence = this.getPathInfluence(x, z);
                    if (pathInfluence > 0) {
                        const pathHeightAbsolute = this.getInterpolatedPathHeight(x, z);
                        const pathHeightRelativeToMountainFoot = pathHeightAbsolute - mountainFootY;
                        const rinnenTiefe = BOARD_CONFIG.pathDepth * pathInfluence * 0.4;
                        y_shape = Math.max(
                            Math.min(y_shape - rinnenTiefe, pathHeightRelativeToMountainFoot + rinnenTiefe * 0.1), 
                            pathHeightRelativeToMountainFoot - rinnenTiefe * 0.4
                        );
                    }
                } else if (distance <= BOARD_CONFIG.mountainBaseRadius * 1.3) {
                    const fadeOut = 1 - ((distance - BOARD_CONFIG.mountainBaseRadius) / (BOARD_CONFIG.mountainBaseRadius * 0.3));
                    y_shape = fadeOut * 0.15 - 0.1;
                } else {
                    y_shape = -0.1;
                }
                
                vertices.push(x, mountainFootY + y_shape, z);
                uvs.push(i / detail, j / detail);
            }
        }

        for (let i = 0; i < detail; i++) {
            for (let j = 0; j < detail; j++) {
                const a = i * (detail + 1) + j;
                const b = a + 1;
                const c = a + detail + 1;
                const d = c + 1;
                indices.push(a, b, c);
                indices.push(b, d, c);
            }
        }

        mountainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        mountainGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        mountainGeometry.setIndex(indices);
        mountainGeometry.computeVertexNormals();

        const mountainTexture = this.createEnhancedMountainTexture();
        const mountainMaterial = new THREE.MeshPhongMaterial({
            map: mountainTexture,
            shininess: 25,
            specular: 0x333333
        });

        const mountainMesh = new THREE.Mesh(mountainGeometry, mountainMaterial);
        mountainMesh.castShadow = true;
        mountainMesh.receiveShadow = true;
        this.scene.add(mountainMesh);
        this.mountainMesh = mountainMesh;
    }

    createEnhancedMountainTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        // Grüner Gradient für Berghänge
        const gradient = ctx.createLinearGradient(0, 0, 0, 1024);
        gradient.addColorStop(0, '#F0F8FF'); // Helle Spitze
        gradient.addColorStop(0.2, '#E8E8E8'); // Schnee oben
        gradient.addColorStop(0.4, '#8FBC8F'); // Helles Grün
        gradient.addColorStop(0.6, '#6B8E23'); // Oliv-Grün
        gradient.addColorStop(0.8, '#228B22'); // Wald-Grün
        gradient.addColorStop(1, '#006400'); // Dunkles Grün unten
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 1024, 1024);

        // Grüne Vegetation und Grasflecken
        for (let i = 0; i < 4000; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = Math.random() * 20 + 8;
            // Mehr Grün in unteren Bereichen
            if (y > 1024 * 0.3) {
                const greenShade = Math.floor(Math.random() * 60) + 40;
                const greenIntensity = Math.floor(Math.random() * 100) + 80;
                ctx.fillStyle = `rgba(${greenShade}, ${greenIntensity}, ${greenShade}, ${Math.random() * 0.4 + 0.2})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Felsstrukturen (weniger dominant)
        for (let i = 0; i < 1500; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const width = Math.random() * 3 + 1;
            const height = Math.random() * 25 + 10;
            // Nur in oberen Bereichen Fels
            if (y < 1024 * 0.4) {
                ctx.fillStyle = `rgba(${Math.random() * 30 + 70}, ${Math.random() * 20 + 60}, ${Math.random() * 10 + 50}, ${Math.random() * 0.2 + 0.1})`;
                ctx.fillRect(x, y, width, height);
            }
        }

        // Schneefelder nur ganz oben
        for (let i = 0; i < 400; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = Math.random() * 12 + 5;
            if (y < 1024 * 0.25) {
                ctx.fillStyle = `rgba(240, 248, 255, ${Math.random() * 0.3 + 0.1})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Mehr Waldvegetation
        for (let i = 0; i < 2000; i++) {
            const x = Math.random() * 1024;
            const y = Math.random() * 1024;
            const radius = Math.random() * 15 + 8;
            if (y > 1024 * 0.2 && y < 1024 * 0.95) {
                const forestGreen = Math.floor(Math.random() * 40) + 60;
                const forestIntensity = Math.floor(Math.random() * 80) + 100;
                ctx.fillStyle = `rgba(${Math.floor(forestGreen * 0.6)}, ${forestIntensity}, ${Math.floor(forestGreen * 0.4)}, ${Math.random() * 0.3 + 0.2})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);
        return texture;
    }

    calculatePathPoints() {
        this.pathPoints = [];
        const fieldCount = 73;
        const lastFieldIndex = fieldCount - 1;
        const mountainFootY = islandSurfaceY;

        for (let i = 0; i < fieldCount; i++) {
            const progress = i / (fieldCount - 1);
            let x, y, z;
            let onFlatLand = false;

            if (i === 0) {
                x = BOARD_CONFIG.spiralStartRadius;
                z = 0;
                y = islandSurfaceY + 0.4;
                onFlatLand = true;
            } else if (i === lastFieldIndex) {
                x = 0;
                y = mountainFootY + BOARD_CONFIG.mountainHeight + 0.3;
                z = BOARD_CONFIG.chamberSize/2 - 0.4;
                onFlatLand = false;
            } else if (i === lastFieldIndex - 1) {
                x = 0;
                y = mountainFootY + BOARD_CONFIG.mountainHeight + 0.4;
                z = BOARD_CONFIG.chamberSize/2 + 1.0;
                onFlatLand = false;
            } else {
                let radius;
                if (progress < 0.08) {
                    radius = BOARD_CONFIG.spiralStartRadius * (1.0 - progress * 5);
                } else if (progress < 0.85) {
                    const localProgress = (progress - 0.08) / 0.77;
                    const easedProgress = Math.pow(localProgress, 0.9);
                    radius = THREE.MathUtils.lerp(BOARD_CONFIG.mountainBaseRadius - 0.6, BOARD_CONFIG.mountainTopRadius * 2, easedProgress);
                } else {
                    const gipfelProgress = (progress - 0.85) / 0.15;
                    radius = BOARD_CONFIG.mountainTopRadius * (2.2 - gipfelProgress * 1);
                }

                const spiralProgress = Math.pow(progress, 0.9);
                const angle = spiralProgress * Math.PI * 2 * BOARD_CONFIG.spiralLoops;
                x = Math.cos(angle) * radius;
                z = Math.sin(angle) * radius;

                const distanceToCenter = Math.sqrt(x * x + z * z);
                if (distanceToCenter > BOARD_CONFIG.mountainBaseRadius - 0.6) {
                    y = islandSurfaceY + 0.4;
                    onFlatLand = true;
                } else {
                    const mountainProgress = Math.max(0, Math.min(1, 1 - (distanceToCenter / (BOARD_CONFIG.mountainBaseRadius - 0.6))));
                    const smoothProgress = Math.pow(mountainProgress, 0.8);
                    y = mountainFootY + smoothProgress * BOARD_CONFIG.mountainHeight;
                    y += Math.sin(angle * 2 + progress * 6) * 0.1;
                    onFlatLand = false;
                }
            }
            this.pathPoints.push({ x, y, z, index: i, onFlatLand });
        }
        this.projectPathPointsOntoMountain();
    }

    projectPathPointsOntoMountain() {
        if (!this.mountainMesh || !this.pathPoints) return;
        for (let i = 0; i < this.pathPoints.length - 2; i++) {
            const point = this.pathPoints[i];
            if (!point.onFlatLand) {
                const raycaster = new THREE.Raycaster();
                const origin = new THREE.Vector3(point.x, BOARD_CONFIG.mountainHeight * 1.5, point.z);
                const direction = new THREE.Vector3(0, -1, 0);
                raycaster.set(origin, direction);
                const intersects = raycaster.intersectObject(this.mountainMesh, false);
                if (intersects.length > 0) {
                    point.y = Math.max(point.y, intersects[0].point.y + 0.25);
                }
            }
        }
    }

    getTerrainHeightAt(x, z) {
        const raycaster = new THREE.Raycaster(new THREE.Vector3(x, BOARD_CONFIG.mountainHeight * 1.5, z), new THREE.Vector3(0, -1, 0));
        const objectsToIntersect = [];
        if (this.mountainMesh) objectsToIntersect.push(this.mountainMesh);
        if (this.island) objectsToIntersect.push(this.island);
        
        const intersects = raycaster.intersectObjects(objectsToIntersect, false);
        if (intersects.length > 0) return intersects[0].point.y;
        return islandSurfaceY;
    }

    getPathInfluence(x, z) {
        let minDistance = Infinity;
        if (!this.pathPoints || this.pathPoints.length === 0) return 0;

        for (let i = 0; i < this.pathPoints.length; i++) {
            const point = this.pathPoints[i];
            const dx = x - point.x;
            const dz = z - point.z;
            minDistance = Math.min(minDistance, Math.sqrt(dx * dx + dz * dz));
        }
        const pathWidth = BOARD_CONFIG.pathWidth * 0.95;
        if (minDistance < pathWidth) {
            return Math.pow(1 - (minDistance / pathWidth), 0.4);
        }
        return 0;
    }

    getInterpolatedPathHeight(x, z) {
        let closestDistance = Infinity;
        let closestIndex = -1;
        let secondClosestDistance = Infinity;
        let secondClosestIndex = -1;
        if (!this.pathPoints || this.pathPoints.length === 0) return islandSurfaceY;

        for (let i = 0; i < this.pathPoints.length; i++) {
            const point = this.pathPoints[i];
            const dx = x - point.x;
            const dz = z - point.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            if (distance < closestDistance) {
                secondClosestDistance = closestDistance;
                secondClosestIndex = closestIndex;
                closestDistance = distance;
                closestIndex = i;
            } else if (distance < secondClosestDistance) {
                secondClosestDistance = distance;
                secondClosestIndex = i;
            }
        }

        if (closestIndex === -1) return islandSurfaceY;
        if (closestDistance < 0.4) return this.pathPoints[closestIndex].y;
        if (secondClosestIndex === -1) {
            return this.pathPoints[closestIndex].y;
        }

        const point1 = this.pathPoints[closestIndex];
        const point2 = this.pathPoints[secondClosestIndex];
        const dx1 = x - point1.x;
        const dz1 = z - point1.z;
        const dist1 = Math.sqrt(dx1*dx1 + dz1*dz1);
        const dx2 = x - point2.x;
        const dz2 = z - point2.z;
        const dist2 = Math.sqrt(dx2*dx2 + dz2*dz2);

        if (dist1 + dist2 === 0) return point1.y;
        const weight1 = 1 - (dist1 / (dist1 + dist2));
        return point1.y * weight1 + point2.y * (1 - weight1);
    }

    createSpiralPath() {
        this.createGameFields();
    }

    createGameFields() {
        if (!this.pathPoints || this.pathPoints.length === 0) {
            console.error("[WiiPartyIsland] Path points not calculated for createGameFields.");
            return;
        }
        this.pathPoints.forEach((point, index) => {
            let type = 'normal';
            if (index === 0) type = 'start';
            else if (index === this.pathPoints.length - 1) type = 'goal';
            else if (index % 7 === 0) type = 'bonus';
            else if (index % 10 === 0) type = 'minigame';
            else if (index % 13 === 0) type = 'chance';
            else if (index % 18 === 0) type = 'trap';

            const field = this.createEnhancedGameField(point, type, index);
            this.boardFields.push({ 
                mesh: field, 
                originalPathPoint: new THREE.Vector3(point.x, point.y, point.z), 
                index: index, 
                type: type 
            });
            this.scene.add(field);
        });
    }

    createEnhancedGameField(point, type, index) {
        const group = new THREE.Group();
        const config = BOARD_CONFIG.fieldTypes[type];
        const fieldRadius = BOARD_CONFIG.fieldRadius * (type === 'start' || type === 'goal' ? 1.2 : 1.0);
        const fieldHeight = BOARD_CONFIG.fieldHeight * (type === 'start' || type === 'goal' ? 1.3 : 1.0);

        // Hauptfeld mit verbesserter Geometrie
        const fieldGeometry = new THREE.CylinderGeometry(fieldRadius, fieldRadius * 1.08, fieldHeight, 20);
        const fieldMaterial = new THREE.MeshPhongMaterial({
            color: config.color,
            shininess: type === 'bonus' || type === 'goal' ? 120 : 60,
            specular: type === 'bonus' || type === 'goal' ? 0xffe375 : 0x777777,
            map: this.createEnhancedFieldTexture(type, config.color)
        });
        
        const fieldMesh = new THREE.Mesh(fieldGeometry, fieldMaterial);
        fieldMesh.position.y = fieldHeight / 2;
        fieldMesh.castShadow = true;
        fieldMesh.receiveShadow = true;
        group.add(fieldMesh);

        // Erweiterte Ringe für spezielle Felder
        if (type === 'minigame' || type === 'bonus' || type === 'chance') {
            const ringGeometry = new THREE.TorusGeometry(fieldRadius * 1.1, 0.05, 10, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(config.color).multiplyScalar(1.8).lerp(new THREE.Color(0xffffff), 0.4),
                transparent: true,
                opacity: 0.9
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = fieldHeight + 0.03;
            group.add(ring);
            
            ring.userData.animation = time => {
                ring.material.opacity = 0.7 + Math.sin(time * 4 + index) * 0.2;
                ring.rotation.z = time * 0.5 + index;
            };
        }

        // Erweiterte Basis
        const baseGeometry = new THREE.CylinderGeometry(fieldRadius * 1.2, fieldRadius * 1.3, 0.15, 20);
        const baseMaterial = new THREE.MeshLambertMaterial({ 
            color: new THREE.Color(config.color).multiplyScalar(0.5) 
        });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.075;
        base.castShadow = true;
        base.receiveShadow = true;
        group.add(base);

        // Partikel-Effekt für besondere Felder
        if (type === 'goal' || type === 'start') {
            this.addFieldParticles(group, fieldRadius, type);
        }

        group.position.set(point.x, point.y, point.z);
        group.userData = { fieldIndex: index, fieldType: type };
        return group;
    }

    addFieldParticles(group, radius, type) {
        const particleCount = 8;
        const particleGeometry = new THREE.SphereGeometry(0.02, 8, 6);
        const particleMaterial = new THREE.MeshBasicMaterial({
            color: type === 'goal' ? 0xffd700 : 0x4fc3f7,
            transparent: true,
            opacity: 0.8
        });

        for (let i = 0; i < particleCount; i++) {
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            const angle = (i / particleCount) * Math.PI * 2;
            particle.position.set(
                Math.cos(angle) * radius * 1.5,
                0.5 + Math.random() * 0.3,
                Math.sin(angle) * radius * 1.5
            );
            group.add(particle);

            particle.userData.animation = time => {
                particle.position.y = 0.5 + Math.sin(time * 2 + i) * 0.3;
                particle.material.opacity = 0.6 + Math.sin(time * 3 + i) * 0.2;
            };
        }
    }

    createEnhancedFieldTexture(type, baseColor) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');

        // Verbesserter Gradient
        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
        const color = new THREE.Color(baseColor);
        gradient.addColorStop(0, color.clone().offsetHSL(0, 0, 0.2).getStyle());
        gradient.addColorStop(0.7, color.getStyle());
        gradient.addColorStop(1, color.clone().offsetHSL(0, 0, -0.2).getStyle());
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);

        // Verbesserte Symbole
        const symbolColor = 'rgba(255,255,255,0.95)';
        const shadowColor = 'rgba(0,0,0,0.4)';
        const shadowOffset = 3;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        if (type === 'start') {
            ctx.font = 'bold 48px Arial';
            ctx.fillStyle = shadowColor;
            ctx.fillText('S', 128 + shadowOffset, 128 + shadowOffset);
            ctx.fillStyle = symbolColor;
            ctx.fillText('S', 128, 128);
        } else if (type === 'goal') {
            ctx.font = 'bold 60px Arial';
            ctx.fillStyle = shadowColor;
            ctx.fillText('★', 128 + shadowOffset, 128 + shadowOffset);
            ctx.fillStyle = 'gold';
            ctx.fillText('★', 128, 128);
        } else if (type === 'minigame') {
            ctx.font = 'bold 36px Arial';
            ctx.fillStyle = shadowColor;
            ctx.fillText('M', 128 + shadowOffset, 128 + shadowOffset);
            ctx.fillStyle = symbolColor;
            ctx.fillText('M', 128, 128);
        } else if (type === 'bonus') {
            ctx.fillStyle = 'rgba(255,223,0,0.8)';
            for(let i = 0; i < 6; i++) {
                ctx.save();
                ctx.translate(Math.random() * 200 + 28, Math.random() * 200 + 28);
                ctx.rotate(Math.random() * Math.PI);
                ctx.fillRect(-20, -20, 40, 40);
                ctx.restore();
            }
        } else if (type === 'chance') {
            ctx.font = 'bold 72px Arial';
            ctx.fillStyle = shadowColor;
            ctx.fillText('?', 128 + shadowOffset, 128 + shadowOffset);
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillText('?', 128, 128);
        } else if (type === 'trap') {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(40, 40);
            ctx.lineTo(216, 216);
            ctx.moveTo(216, 40);
            ctx.lineTo(40, 216);
            ctx.stroke();
        } else {
            for(let i = 0; i < 10; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * 256, Math.random() * 256, Math.random() * 15 + 8, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.15 + 0.1})`;
                ctx.fill();
            }
        }

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    createEnhancedVegetation() {
        // Verbesserte Palmen
        for (let i = 0; i < 15; i++) {
            const angle = (i / 15) * Math.PI * 2 + Math.random() * 0.3;
            const radius = BOARD_CONFIG.mountainBaseRadius + 4 + Math.random() * 8;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            if (this.isPositionSafe(x, z, 3)) {
                const palm = this.createEnhancedPalmTree();
                const terrainY = this.getTerrainHeightAt(x, z);
                palm.position.set(x, terrainY, z);
                palm.scale.setScalar(0.8 + Math.random() * 0.6);
                palm.rotation.y = Math.random() * Math.PI * 2;
                this.scene.add(palm);
            }
        }

        // Verbesserte Büsche
        for (let i = 0; i < 35; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = BOARD_CONFIG.mountainBaseRadius * 0.6 + Math.random() * (BOARD_CONFIG.mountainBaseRadius * 0.7);
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            if (this.isPositionSafe(x, z, 2)) {
                const bush = this.createEnhancedBush();
                const terrainY = this.getTerrainHeightAt(x, z);
                bush.position.set(x, terrainY, z);
                bush.scale.setScalar(0.5 + Math.random() * 0.7);
                this.scene.add(bush);
            }
        }
    }

    createEnhancedPalmTree() {
        const palmGroup = new THREE.Group();
        const trunkHeight = 5 + Math.random() * 2.5;
        const trunkTopRadius = 0.18 + Math.random() * 0.12;
        const trunkBottomRadius = trunkTopRadius + 0.12 + Math.random() * 0.12;

        // Verbesserter Stamm
        const trunkGeometry = new THREE.CylinderGeometry(trunkTopRadius, trunkBottomRadius, trunkHeight, 12);
        const trunkTexture = this.createPalmTrunkTexture();
        const trunkMaterial = new THREE.MeshPhongMaterial({ 
            map: trunkTexture, 
            shininess: 8 
        });
        
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = trunkHeight / 2;
        trunk.castShadow = true;
        trunk.receiveShadow = true;

        // Stammdeformation
        for(let i = 0; i < trunk.geometry.attributes.position.count; i++) {
            const yPos = trunk.geometry.attributes.position.getY(i);
            const bendFactor = Math.sin((yPos / trunkHeight) * Math.PI) * 0.15;
            trunk.geometry.attributes.position.setX(i, 
                trunk.geometry.attributes.position.getX(i) + bendFactor * (Math.random() - 0.5)
            );
        }
        trunk.geometry.attributes.position.needsUpdate = true;
        trunk.geometry.computeVertexNormals();
        palmGroup.add(trunk);

        // Verbesserte Blätter
        const leavesGroup = new THREE.Group();
        leavesGroup.position.y = trunkHeight;
        const numLeaves = 8 + Math.floor(Math.random() * 6);
        
        for (let i = 0; i < numLeaves; i++) {
            const leafLength = 2.2 + Math.random() * 1;
            const leafWidth = 1 + Math.random() * 0.5;
            const leafGeometry = new THREE.PlaneGeometry(leafWidth, leafLength, 4, 8);
            leafGeometry.translate(0, leafLength / 2, 0);
            
            // Blattdeformation für natürlicheres Aussehen
            const positions = leafGeometry.attributes.position.array;
            for (let j = 0; j < positions.length; j += 3) {
                const y = positions[j + 1];
                const bendAmount = (y / leafLength) * 0.3;
                positions[j] += Math.sin(y * 0.5) * bendAmount;
                positions[j + 2] += Math.cos(y * 0.3) * bendAmount * 0.5;
            }
            leafGeometry.attributes.position.needsUpdate = true;
            leafGeometry.computeVertexNormals();

            const leafMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(0x228B22).lerp(new THREE.Color(0x32CD32), Math.random()),
                side: THREE.DoubleSide,
                shininess: 30,
                transparent: true,
                opacity: 0.9
            });
            
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.rotation.z = Math.PI / 4 + (Math.random() - 0.5) * 0.6;
            leaf.rotation.y = (i / numLeaves) * Math.PI * 2 + (Math.random() - 0.5) * 0.3;
            leaf.rotation.x = (Math.random() - 0.5) * 0.4;
            leaf.castShadow = true;
            leaf.receiveShadow = true;
            leavesGroup.add(leaf);

            // Blattanimation
            leaf.userData.animation = time => {
                const swayAmount = 0.1;
                leaf.rotation.z = Math.PI / 4 + (Math.random() - 0.5) * 0.6 + 
                                Math.sin(time * 2 + i) * swayAmount;
            };
        }
        palmGroup.add(leavesGroup);
        return palmGroup;
    }

    createPalmTrunkTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Gradient für Stamm
        const gradient = ctx.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#8B4513');
        gradient.addColorStop(0.5, '#A0522D');
        gradient.addColorStop(1, '#654321');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 128, 512);

        // Rindenstruktur
        for(let i = 0; i < 80; i++) {
            ctx.strokeStyle = `rgba(${Math.random() * 40 + 40}, ${Math.random() * 20 + 20}, ${Math.random() * 10 + 5}, ${Math.random() * 0.4 + 0.2})`;
            ctx.lineWidth = Math.random() * 4 + 2;
            const y = Math.random() * 512;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(128, y + (Math.random() - 0.5) * 20);
            ctx.stroke();
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        return texture;
    }

    createEnhancedBush() {
        const bushGroup = new THREE.Group();
        const colors = [0x228B22, 0x32CD32, 0x6B8E23, 0x9ACD32, 0x7CFC00];
        const numElements = 5 + Math.floor(Math.random() * 4);
        
        for (let i = 0; i < numElements; i++) {
            const radius = 0.25 + Math.random() * 0.2;
            const bushGeometry = new THREE.SphereGeometry(radius, 12, 10);
            
            // Deformation für natürlichere Form
            const positions = bushGeometry.attributes.position.array;
            for (let j = 0; j < positions.length; j += 3) {
                const factor = 0.1 + Math.random() * 0.1;
                positions[j] *= 1 + (Math.random() - 0.5) * factor;
                positions[j + 1] *= 1 + (Math.random() - 0.5) * factor;
                positions[j + 2] *= 1 + (Math.random() - 0.5) * factor;
            }
            bushGeometry.attributes.position.needsUpdate = true;
            bushGeometry.computeVertexNormals();

            const bushMaterial = new THREE.MeshLambertMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)]
            });
            
            const bushElement = new THREE.Mesh(bushGeometry, bushMaterial);
            bushElement.position.set(
                (Math.random() - 0.5) * 0.8,
                radius * 0.6 + (Math.random() - 0.5) * 0.15,
                (Math.random() - 0.5) * 0.8
            );
            bushElement.scale.setScalar(0.7 + Math.random() * 0.6);
            bushElement.castShadow = true;
            bushElement.receiveShadow = true;
            bushGroup.add(bushElement);
        }
        return bushGroup;
    }

    createTreasureChamber() {
        const chamberGroup = new THREE.Group();
        const chamberSize = BOARD_CONFIG.chamberSize;
        const chamberHeight = chamberSize * 0.8;
        const chamberWallThickness = 0.35;
        chamberGroup.position.set(0, islandSurfaceY + BOARD_CONFIG.mountainHeight, 0);

        const stoneTexture = this.createEnhancedStoneTexture();
        const floorMaterial = new THREE.MeshPhongMaterial({ map: stoneTexture, shininess: 25 });
        const wallMaterial = new THREE.MeshPhongMaterial({ map: stoneTexture, shininess: 25 });

        // Boden
        const floor = new THREE.Mesh(
            new THREE.BoxGeometry(chamberSize, chamberWallThickness, chamberSize), 
            floorMaterial
        );
        floor.position.y = -chamberWallThickness/2;
        floor.receiveShadow = true;
        floor.castShadow = true;
        chamberGroup.add(floor);

        // Verbessertes Dach
        const roofMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xB8860B, 
            shininess: 100, 
            specular: 0xFFD700 
        });
        const roof = new THREE.Mesh(
            new THREE.BoxGeometry(chamberSize * 1.15, chamberWallThickness * 1.8, chamberSize * 1.15), 
            roofMaterial
        );
        roof.position.y = chamberHeight + chamberWallThickness * 0.9;
        roof.castShadow = true;
        chamberGroup.add(roof);

        // Wände mit verbesserter Eingangslogik
        for (let i = 0; i < 4; i++) {
            const isEntranceSide = (i === 2);

            if (isEntranceSide) {
                const entranceWidth = chamberSize * 0.45;
                const sideWallWidth = (chamberSize - entranceWidth) / 2;

                const leftWall = new THREE.Mesh(
                    new THREE.BoxGeometry(sideWallWidth, chamberHeight, chamberWallThickness), 
                    wallMaterial
                );
                leftWall.position.set(-entranceWidth/2 - sideWallWidth/2, chamberHeight/2, chamberSize/2);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                chamberGroup.add(leftWall);

                const rightWall = new THREE.Mesh(
                    new THREE.BoxGeometry(sideWallWidth, chamberHeight, chamberWallThickness), 
                    wallMaterial
                );
                rightWall.position.set(entranceWidth/2 + sideWallWidth/2, chamberHeight/2, chamberSize/2);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                chamberGroup.add(rightWall);

                const lintelHeight = chamberHeight * 0.25;
                const lintel = new THREE.Mesh(
                    new THREE.BoxGeometry(entranceWidth, lintelHeight, chamberWallThickness), 
                    wallMaterial
                );
                lintel.position.set(0, chamberHeight - lintelHeight/2, chamberSize/2);
                lintel.castShadow = true;
                lintel.receiveShadow = true;
                chamberGroup.add(lintel);

                // Verbesserte Tür
                const doorHeight = chamberHeight - lintelHeight;
                const doorMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x654321, 
                    shininess: 40, 
                    map: this.createEnhancedWoodTexture() 
                });
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(entranceWidth * 0.92, doorHeight * 0.96, chamberWallThickness/1.3), 
                    doorMaterial
                );
                door.position.set(0, doorHeight * 0.96 / 2, chamberSize/2);
                door.castShadow = true;
                door.receiveShadow = true;
                chamberGroup.add(door);
                this.chamberDoor = door;

                // Verbesserter Türgriff
                const handleMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xDAA520, 
                    shininess: 150, 
                    specular: 0xFFD700 
                });
                const handle = new THREE.Mesh(
                    new THREE.TorusKnotGeometry(0.12, 0.04, 64, 12), 
                    handleMaterial
                );
                handle.position.set(-entranceWidth*0.35, doorHeight*0.5, chamberWallThickness/2);
                door.add(handle);

            } else {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(chamberSize, chamberHeight, chamberWallThickness), 
                    wallMaterial
                );
                if (i === 0) {
                    wall.position.set(0, chamberHeight/2, -chamberSize/2);
                } else if (i === 1) {
                    wall.position.set(chamberSize/2, chamberHeight/2, 0);
                    wall.rotation.y = Math.PI / 2;
                } else if (i === 3) {
                    wall.position.set(-chamberSize/2, chamberHeight/2, 0);
                    wall.rotation.y = Math.PI / 2;
                }
                wall.castShadow = true;
                wall.receiveShadow = true;
                chamberGroup.add(wall);
            }
        }

        this.createEnhancedTreasure(chamberGroup, chamberSize);
        this.decorateEnhancedChamber(chamberGroup, chamberSize);
        this.scene.add(chamberGroup);
        this.treasureChamber = chamberGroup;
    }

    createEnhancedStoneTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Gradient-Basis
        const gradient = ctx.createLinearGradient(0, 0, 512, 512);
        gradient.addColorStop(0, '#B8B8B8');
        gradient.addColorStop(0.5, '#A0A0A0');
        gradient.addColorStop(1, '#909090');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 512, 512);

        // Steinstruktur
        for(let i = 0; i < 200; i++) {
            ctx.fillStyle = `rgba(${Math.random() * 60 + 140}, ${Math.random() * 60 + 140}, ${Math.random() * 60 + 140}, ${Math.random() * 0.6 + 0.2})`;
            ctx.beginPath();
            ctx.arc(Math.random() * 512, Math.random() * 512, Math.random() * 25 + 8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Verbesserste Fugen
        ctx.strokeStyle = 'rgba(70,70,70,0.6)';
        ctx.lineWidth = 3;
        for(let i = 0; i < 12; i++) {
            ctx.beginPath();
            ctx.moveTo(Math.random() * 512, 0);
            ctx.lineTo(Math.random() * 512, 512);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, Math.random() * 512);
            ctx.lineTo(512, Math.random() * 512);
            ctx.stroke();
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(2, 2);
        return texture;
    }

    createEnhancedWoodTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        // Gradient für Holz
        const gradient = ctx.createLinearGradient(0, 0, 256, 0);
        gradient.addColorStop(0, '#8B4513');
        gradient.addColorStop(0.3, '#A0522D');
        gradient.addColorStop(0.7, '#CD853F');
        gradient.addColorStop(1, '#8B4513');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 512);

        // Holzmaserung
        for(let i = 0; i < 60; i++) {
            ctx.strokeStyle = `rgba(${Math.random() * 40 + 40}, ${Math.random() * 20 + 20}, ${Math.random() * 10 + 5}, ${Math.random() * 0.4 + 0.3})`;
            ctx.lineWidth = Math.random() * 4 + 1;
            ctx.beginPath();
            ctx.moveTo(Math.random() * 256, 0);
            ctx.lineTo(Math.random() * 256, 512);
            ctx.stroke();
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);
        return texture;
    }

    createEnhancedTreasure(chamberGroup, chamberSize) {
        const treasurePile = new THREE.Group();
        const baseRadius = chamberSize * 0.25;
        const pileHeight = chamberSize * 0.18;

        // Verbesserte Goldmünzen
        const coinGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.012, 16);
        const coinMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFD700,
            shininess: 150,
            specular: 0xFFEC8B,
            reflectivity: 0.8
        });

        for(let i = 0; i < 300; i++) {
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            const r = Math.random() * baseRadius;
            const angle = Math.random() * Math.PI * 2;
            const h = Math.random() * pileHeight * (1 - (r/baseRadius));
            coin.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
            coin.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            coin.castShadow = true;
            treasurePile.add(coin);
        }

        // Verbesserte Edelsteine
        const gemColors = [0xFF4500, 0x4169E1, 0x32CD32, 0xDA70D6, 0xFF1493, 0x00CED1];
        const gemGeometry = new THREE.OctahedronGeometry(0.1, 0);
        
        for(let i = 0; i < 30; i++) {
            const gemMaterial = new THREE.MeshPhongMaterial({
                color: gemColors[Math.floor(Math.random()*gemColors.length)],
                shininess: 200,
                specular: 0xffffff,
                transparent: true,
                opacity: 0.85,
                reflectivity: 0.9
            });
            const gem = new THREE.Mesh(gemGeometry, gemMaterial);
            const r = Math.random() * baseRadius * 0.9;
            const angle = Math.random() * Math.PI * 2;
            const h = Math.random() * pileHeight * 1.3;
            gem.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
            gem.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            gem.castShadow = true;
            treasurePile.add(gem);

            // Edelstein-Animation
            gem.userData.animation = time => {
                gem.rotation.y += 0.01;
                gem.material.opacity = 0.7 + Math.sin(time * 2 + i) * 0.15;
            };
        }

        treasurePile.position.y = chamberSize * 0.06;
        chamberGroup.add(treasurePile);
        this.treasurePile = treasurePile;
    }

    decorateEnhancedChamber(chamberGroup, chamberSize) {
        // Verbesserte Fackeln
        for(let i = 0; i < 4; i++) {
            const torchGroup = new THREE.Group();
            
            // Fackelstiel
            const handleGeom = new THREE.CylinderGeometry(0.06, 0.08, 1, 12);
            const handleMat = new THREE.MeshPhongMaterial({color: 0x5C3317, shininess: 15});
            const handle = new THREE.Mesh(handleGeom, handleMat);
            handle.position.y = 0.5;
            torchGroup.add(handle);

            // Verbesserte Flamme
            const flameGeom = new THREE.ConeGeometry(0.18, 0.5, 16);
            const flameMat = new THREE.MeshBasicMaterial({
                color: 0xFF8C00,
                transparent: true,
                opacity: 0.8
            });
            const flame = new THREE.Mesh(flameGeom, flameMat);
            flame.position.y = 1.25;
            torchGroup.add(flame);

            // Verbessertes Licht
            const flameLight = new THREE.PointLight(0xFF6600, 2, 4);
            flameLight.position.y = 1.4;
            flameLight.castShadow = true;
            flameLight.shadow.mapSize.width = 1024;
            flameLight.shadow.mapSize.height = 1024;
            flame.add(flameLight);
            flame.userData.light = flameLight;

            // Erweiterte Flackeranimation
            flame.userData.animation = time => {
                const flicker = Math.sin(time * 20 + i * 3) * 0.15;
                flame.scale.set(
                    1 + flicker, 
                    1 + Math.cos(time * 25 + i * 2) * 0.2, 
                    1 + flicker
                );
                flameLight.intensity = 1.8 + Math.sin(time * 30 + i * 4) * 0.8;
                flame.material.opacity = 0.6 + Math.sin(time * 15 + i) * 0.2;
            };

            // Fackel-Positionierung
            const positions = [
                [-chamberSize*0.35, 0.2, -chamberSize*0.4],
                [chamberSize*0.35, 0.2, -chamberSize*0.4],
                [-chamberSize*0.4, 0.2, 0],
                [chamberSize*0.4, 0.2, 0]
            ];
            torchGroup.position.set(...positions[i]);
            torchGroup.rotation.x = -Math.PI/16;
            chamberGroup.add(torchGroup);
        }

        // Zusätzliche Dekoration: Kristalle
        for(let i = 0; i < 6; i++) {
            const crystalGeom = new THREE.ConeGeometry(0.1, 0.4, 6);
            const crystalMat = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.7,
                shininess: 200
            });
            const crystal = new THREE.Mesh(crystalGeom, crystalMat);
            
            const angle = (i / 6) * Math.PI * 2;
            crystal.position.set(
                Math.cos(angle) * chamberSize * 0.45,
                0.2,
                Math.sin(angle) * chamberSize * 0.45
            );
            crystal.rotation.x = Math.random() * 0.3;
            crystal.rotation.z = Math.random() * 0.3;
            chamberGroup.add(crystal);

            crystal.userData.animation = time => {
                crystal.rotation.y = time * 0.5 + i;
                crystal.material.opacity = 0.5 + Math.sin(time * 3 + i) * 0.2;
            };
        }
    }

    createAdvancedEnvironmentalDetails() {
        this.createEnhancedClouds();
        this.createEnhancedWildlife();
        this.createAtmosphericParticles();
    }

    createEnhancedClouds() {
        const cloudMaterial = new THREE.MeshPhongMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.9,
            shininess: 5
        });

        for(let i = 0; i < 16; i++) {
            const cloudGroup = new THREE.Group();
            const numPuffs = 6 + Math.floor(Math.random() * 6);
            
            for(let j = 0; j < numPuffs; j++) {
                const puffRadius = 0.9 + Math.random() * 0.9;
                const puff = new THREE.Mesh(
                    new THREE.SphereGeometry(puffRadius, 12, 10),
                    cloudMaterial
                );
                puff.position.set(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 2
                );
                puff.castShadow = true;
                cloudGroup.add(puff);
            }

            const angle = Math.random() * Math.PI * 2;
            const radius = 50 + Math.random() * 40;
            cloudGroup.position.set(
                Math.cos(angle) * radius,
                BOARD_CONFIG.mountainHeight + 12 + Math.random() * 20,
                Math.sin(angle) * radius
            );
            cloudGroup.scale.setScalar(1.8 + Math.random() * 1.2);
            
            cloudGroup.userData = {
                speed: 0.008 + Math.random() * 0.015,
                direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                animation: function(time) {
                    this.parentMesh.position.addScaledVector(this.direction, this.speed);
                    if(this.parentMesh.position.length() > 120) {
                        const newAngle = Math.random() * Math.PI * 2;
                        this.parentMesh.position.set(
                            Math.cos(newAngle) * 110,
                            BOARD_CONFIG.mountainHeight + 12 + Math.random() * 20,
                            Math.sin(newAngle) * 110
                        );
                    }
                    // Sanfte Rotation
                    this.parentMesh.rotation.y += 0.001;
                }
            };
            cloudGroup.userData.parentMesh = cloudGroup;
            this.clouds.push(cloudGroup);
            this.scene.add(cloudGroup);
        }
    }

    createEnhancedWildlife() {
        // Verbesserte Vögel
        for(let i = 0; i < 5; i++) {
            const bird = this.createEnhancedBird();
            const startRadius = 35 + Math.random() * 25;
            const startAngle = Math.random() * Math.PI * 2;
            bird.position.set(
                Math.cos(startAngle) * startRadius,
                BOARD_CONFIG.mountainHeight + 8 + Math.random() * 15,
                Math.sin(startAngle) * startRadius
            );
            
            bird.userData = {
                center: new THREE.Vector3(0, bird.position.y, 0),
                radius: startRadius,
                angle: startAngle,
                speed: 0.015 + Math.random() * 0.008,
                verticalOffset: Math.random() * Math.PI * 2,
                animation: function(time) {
                    this.angle += this.speed;
                    const verticalMovement = Math.sin(time * 2 + this.verticalOffset) * 2;
                    this.parentMesh.position.x = Math.cos(this.angle) * this.radius;
                    this.parentMesh.position.z = Math.sin(this.angle) * this.radius;
                    this.parentMesh.position.y = this.center.y + verticalMovement;
                    this.parentMesh.rotation.y = -this.angle + Math.PI/2;
                    
                    // Erweiterte Flügelanimation
                    this.parentMesh.children.forEach(child => {
                        if(child.name === "wing") {
                            child.rotation.z = Math.sin(time * 30 + this.angle) * 1.2;
                        }
                    });
                }
            };
            bird.userData.parentMesh = bird;
            this.birds.push(bird);
            this.scene.add(bird);
        }
    }

    createEnhancedBird() {
        const birdGroup = new THREE.Group();
        
        // Verbesserter Körper
        const bodyGeom = new THREE.SphereGeometry(0.18, 12, 8);
        bodyGeom.scale(1, 0.8, 1.8);
        const bodyMat = new THREE.MeshPhongMaterial({color: 0x4A4A4A, shininess: 30});
        const body = new THREE.Mesh(bodyGeom, bodyMat);
        birdGroup.add(body);

        // Kopf
        const headGeom = new THREE.SphereGeometry(0.12, 10, 8);
        const headMat = new THREE.MeshPhongMaterial({color: 0x333333, shininess: 25});
        const head = new THREE.Mesh(headGeom, headMat);
        head.position.set(0, 0.1, 0.25);
        body.add(head);

        // Schnabel
        const beakGeom = new THREE.ConeGeometry(0.03, 0.15, 8);
        const beakMat = new THREE.MeshPhongMaterial({color: 0xFFA500, shininess: 40});
        const beak = new THREE.Mesh(beakGeom, beakMat);
        beak.position.set(0, 0, 0.15);
        beak.rotation.x = Math.PI / 2;
        head.add(beak);

        // Verbesserte Flügel
        const wingGeom = new THREE.BoxGeometry(0.8, 0.04, 0.25);
        const wingMat = new THREE.MeshPhongMaterial({color: 0x333333, shininess: 20});
        
        for(let i = 0; i < 2; i++) {
            const wing = new THREE.Mesh(wingGeom, wingMat);
            wing.name = "wing";
            wing.position.set(i === 0 ? -0.4 : 0.4, 0, 0);
            wing.rotation.x = Math.PI / 16;
            body.add(wing);
        }

        // Schwanz
        const tailGeom = new THREE.BoxGeometry(0.2, 0.02, 0.4);
        const tailMat = new THREE.MeshPhongMaterial({color: 0x222222, shininess: 15});
        const tail = new THREE.Mesh(tailGeom, tailMat);
        tail.position.set(0, 0, -0.3);
        body.add(tail);

        birdGroup.scale.setScalar(0.9 + Math.random() * 0.5);
        return birdGroup;
    }

    createAtmosphericParticles() {
        // Schwebende Partikel für Atmosphäre
        const particleGeometry = new THREE.SphereGeometry(0.02, 6, 6);
        const particleMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFFFFF,
            transparent: true,
            opacity: 0.6
        });

        for(let i = 0; i < 50; i++) {
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.set(
                (Math.random() - 0.5) * 200,
                Math.random() * 60 + 10,
                (Math.random() - 0.5) * 200
            );
            
            particle.userData = {
                speed: 0.02 + Math.random() * 0.03,
                direction: new THREE.Vector3(Math.random() - 0.5, Math.random() * 0.1, Math.random() - 0.5).normalize(),
                animation: function(time) {
                    this.parentMesh.position.addScaledVector(this.direction, this.speed);
                    this.parentMesh.material.opacity = 0.3 + Math.sin(time * 2 + this.parentMesh.position.x) * 0.3;
                    
                    // Reset position wenn zu weit weg
                    if(this.parentMesh.position.length() > 150) {
                        this.parentMesh.position.set(
                            (Math.random() - 0.5) * 100,
                            Math.random() * 60 + 10,
                            (Math.random() - 0.5) * 100
                        );
                    }
                }
            };
            particle.userData.parentMesh = particle;
            this.particles.push(particle);
            this.scene.add(particle);
        }
    }

    isPositionSafe(x, z, minDist) {
        if (!this.pathPoints || this.pathPoints.length === 0) return true;
        for(const point of this.pathPoints) {
            const dx = x - point.x;
            const dz = z - point.z;
            if(Math.sqrt(dx*dx + dz*dz) < minDist) return false;
        }
        
        if(Math.sqrt(x*x + z*z) < BOARD_CONFIG.mountainBaseRadius * 0.9 && 
           this.getTerrainHeightAt(x,z) > islandSurfaceY + 3) {
            if (this.getPathInfluence(x,z) < 0.15) return false;
        }
        return true;
    }

    setupEventListeners() {
        window.addEventListener('resize', this.updateCanvasSize);

        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'm') {
                GAME_STATE.freeCameraMode = !GAME_STATE.freeCameraMode;
                this.controls.enabled = GAME_STATE.freeCameraMode;
                
                if (GAME_STATE.freeCameraMode) {
                    // Stoppe cinematische Modi
                    GAME_STATE.cinematicMode = false;
                    if (GAME_STATE.cinematicTimer) {
                        clearTimeout(GAME_STATE.cinematicTimer);
                        GAME_STATE.cinematicTimer = null;
                    }
                    this.showStatusMessage('Freie Kamera aktiviert (M zum Deaktivieren)', 3000, 'info');
                } else {
                    this.showStatusMessage('Automatische Kameraführung aktiviert', 3000, 'info');
                    if (localTeams && localTeams.length > 0) {
                        this.stopCameraFollow();
                        this.setOverviewCamera();
                    }
                }
            } else if (event.key.toLowerCase() === 'f') {
                this.toggleFullscreen();
            } else if (event.key.toLowerCase() === 'c' && !GAME_STATE.freeCameraMode) {
                if (GAME_STATE.cameraMode === 'overview') {
                    GAME_STATE.cameraMode = 'follow';
                    this.focusCameraOnCurrentTeam(false);
                    this.showStatusMessage('Folgemodus aktiviert', 3000, 'info');
                } else if (GAME_STATE.cameraMode === 'follow') {
                    GAME_STATE.cameraMode = 'cinematic';
                    this.startCinematicIntro();
                    this.showStatusMessage('Cinematischer Modus aktiviert', 3000, 'info');
                } else {
                    GAME_STATE.cameraMode = 'overview';
                    GAME_STATE.cinematicMode = false;
                    if (GAME_STATE.cinematicTimer) {
                        clearTimeout(GAME_STATE.cinematicTimer);
                        GAME_STATE.cinematicTimer = null;
                    }
                    this.setOverviewCamera();
                    this.showStatusMessage('Übersichtsmodus aktiviert', 3000, 'info');
                }
            }
        });
    }

    showStatusMessage(message, duration = 3000, type = 'info') {
        const existingMessage = document.querySelector('.status-message');
        if (existingMessage) existingMessage.remove();
        
        const statusDiv = document.createElement('div');
        statusDiv.className = `status-message status-${type}`;
        statusDiv.textContent = message;
        document.body.appendChild(statusDiv);
        
        setTimeout(() => {
            if (statusDiv.parentNode) statusDiv.remove();
        }, duration);
    }

    getCurrentTeam() {
        if (localTeams && localTeams.length > 0 && GAME_STATE.currentServerTeamTurnId != null) {
            return localTeams.find(t => t.id === GAME_STATE.currentServerTeamTurnId);
        }
        
        if (localTeams && localTeams.length > 0 && GAME_STATE.diceRollOrderFromServer && GAME_STATE.diceRollOrderFromServer.length > 0) {
            const firstTeamIdInOrder = parseInt(GAME_STATE.diceRollOrderFromServer[0]);
            if (!isNaN(firstTeamIdInOrder)) {
                return localTeams.find(t => t.id === firstTeamIdInOrder);
            }
        }
        return null;
    }

    updateTeamDisplay() {
        const currentTeam = this.getCurrentTeam();
        const currentTeamDisplayEl = document.getElementById('current-team');

        if (currentTeamDisplayEl) {
            currentTeamDisplayEl.textContent = currentTeam ? currentTeam.name : 'Fabian'; // Fallback
        }

        document.querySelectorAll('.team-badge').forEach(badge => badge.classList.remove('active-team'));
        if (currentTeam) {
            const teamBadgeEl = document.getElementById(`team-badge-${currentTeam.id}`);
            if (teamBadgeEl) {
                teamBadgeEl.classList.add('active-team');
            }
        }
        
        // UI-Sichtbarkeit direkt hier sicherstellen
        setTimeout(() => {
            const overlay = document.querySelector('.game-overlay');
            if (overlay) {
                overlay.style.display = 'flex';
                overlay.style.opacity = '1';
                overlay.style.visibility = 'visible';
            }
            
            const currentTeamDisplay = document.querySelector('.current-team-display');
            if (currentTeamDisplay) {
                currentTeamDisplay.style.display = 'block';
                currentTeamDisplay.style.opacity = '1';
                currentTeamDisplay.style.visibility = 'visible';
            }
            
            const teamStatus = document.querySelector('.team-status');
            if (teamStatus) {
                teamStatus.style.display = 'flex';
                teamStatus.style.opacity = '1';
                teamStatus.style.visibility = 'visible';
            }
        }, 100);
    }

    setOverviewCamera(immediate = false, callback) {
        const targetPos = new THREE.Vector3(0, BOARD_CONFIG.mountainHeight * 1.4, BOARD_CONFIG.spiralStartRadius * 1.8);
        const lookAtPos = new THREE.Vector3(0, BOARD_CONFIG.mountainHeight * 0.4, 0);

        this.stopCameraFollow();
        this.animateCameraToPosition(targetPos, lookAtPos, immediate ? 0 : 1800, callback);
    }

    focusCameraOnCurrentTeam(immediate = false, callback) {
        if (GAME_STATE.cameraMode !== 'follow') {
            if (callback) callback();
            return;
        }

        const currentTeam = this.getCurrentTeam();
        if (!currentTeam || !this.miiCharacters[currentTeam.id] || GAME_STATE.freeCameraMode) {
            if (callback) callback();
            return;
        }
        
        const character = this.miiCharacters[currentTeam.id];
        this.startCameraFollow(character, immediate, callback);
    }

    startCameraFollow(character, immediate = false, callback) {
        if (!character || GAME_STATE.freeCameraMode) {
            if(callback) callback();
            return;
        }
        this.isFollowingCharacter = true;
        this.followTarget = character;
        this.updateCameraFollow(immediate, callback);
    }

    stopCameraFollow() {
        this.isFollowingCharacter = false;
        this.followTarget = null;
    }

    updateCameraFollow(immediate = false, callback) {
        if (!this.isFollowingCharacter || !this.followTarget || GAME_STATE.freeCameraMode) {
            if(callback) callback();
            return;
        }

        const targetPos = this.followTarget.position.clone();
        const camOffset = BOARD_CONFIG.cameraFollowOffset.clone();
        const desiredCamPos = targetPos.clone().add(camOffset);
        const lookAtPos = targetPos.clone().add(new THREE.Vector3(0, 2.5, 0));

        if (immediate) {
            this.camera.position.copy(desiredCamPos);
            this.camera.lookAt(lookAtPos);
            this.controls.target.copy(lookAtPos);
            if(callback) callback();
        } else {
            this.animateCameraToPosition(desiredCamPos, lookAtPos, 1500, callback);
        }
    }

    animateCameraToPosition(targetCamPos, targetLookAtPos, duration = 1500, callback) {
        if (GAME_STATE.isAnimatingCamera && duration > 0) {
            if (callback) callback();
            return;
        }
        GAME_STATE.isAnimatingCamera = true;

        if (typeof gsap !== 'undefined' && duration > 0) {
            gsap.to(this.camera.position, {
                duration: duration / 1000,
                x: targetCamPos.x, 
                y: targetCamPos.y, 
                z: targetCamPos.z,
                ease: "power2.inOut"
            });
            
            gsap.to(this.controls.target, {
                duration: duration / 1000,
                x: targetLookAtPos.x, 
                y: targetLookAtPos.y, 
                z: targetLookAtPos.z,
                ease: "power2.inOut",
                onUpdate: () => this.camera.lookAt(this.controls.target),
                onComplete: () => {
                    GAME_STATE.isAnimatingCamera = false;
                    if (callback) callback();
                }
            });
        } else {
            this.camera.position.copy(targetCamPos);
            this.controls.target.copy(targetLookAtPos);
            this.camera.lookAt(this.controls.target);
            GAME_STATE.isAnimatingCamera = false;
            if (callback) callback();
        }
    }

    easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    createDiceFaceTexture(number) {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Verbesserter Gradient für Würfelseiten
        const gradient = ctx.createLinearGradient(0, 0, 256, 256);
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(0.5, '#f8f8f8');
        gradient.addColorStop(1, '#f0f0f0');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);
        
        // Rand
        ctx.strokeStyle = '#dddddd';
        ctx.lineWidth = 256/15;
        ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, 256-ctx.lineWidth, 256-ctx.lineWidth);
        
        // Punkte mit 3D-Effekt
        ctx.fillStyle = '#333333';
        const dotRadius = 256/10;
        const padding = 256/4;
        
        const positions = {
            1: [[256/2, 256/2]],
            2: [[padding, padding], [256-padding, 256-padding]],
            3: [[padding, padding], [256/2, 256/2], [256-padding, 256-padding]],
            4: [[padding, padding], [256-padding, padding], [padding, 256-padding], [256-padding, 256-padding]],
            5: [[padding, padding], [256-padding, padding], [256/2, 256/2], [padding, 256-padding], [256-padding, 256-padding]],
            6: [[padding, padding], [256-padding, padding], [padding, 256/2], [256-padding, 256/2], [padding, 256-padding], [256-padding, 256-padding]]
        };
        
        if(positions[number]) {
            positions[number].forEach(pos => {
                // Schatten
                ctx.fillStyle = '#222222';
                ctx.beginPath();
                ctx.arc(pos[0]+3, pos[1]+3, dotRadius, 0, Math.PI*2);
                ctx.fill();
                
                // 3D-Effekt für Punkte
                const dotGradient = ctx.createRadialGradient(pos[0]-dotRadius/3, pos[1]-dotRadius/3, 0, pos[0], pos[1], dotRadius);
                dotGradient.addColorStop(0, '#555555');
                dotGradient.addColorStop(0.7, '#333333');
                dotGradient.addColorStop(1, '#222222');
                ctx.fillStyle = dotGradient;
                ctx.beginPath();
                ctx.arc(pos[0], pos[1], dotRadius, 0, Math.PI*2);
                ctx.fill();
            });
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    createInteractiveDice() {
        const diceSize = 0.7;
        const geometry = new THREE.BoxGeometry(diceSize, diceSize, diceSize);
        const materials = [];
        
        for(let i = 1; i <= 6; i++) {
            materials.push(new THREE.MeshPhongMaterial({ 
                map: this.createDiceFaceTexture(i), 
                shininess: 100, 
                specular: 0xe8e8e8 
            }));
        }
        
        const orderedMaterials = [materials[0], materials[5], materials[1], materials[4], materials[2], materials[3]];
        this.interactiveDice = new THREE.Mesh(geometry, orderedMaterials);
        this.interactiveDice.castShadow = true;
        this.interactiveDice.receiveShadow = true;
        this.interactiveDice.visible = false;
        this.interactiveDice.userData.isDice = true;
        this.scene.add(this.interactiveDice);
    }

    animateCharacterTurn(character, targetLookAtPosition, callback, duration = 600) {
        if (!character) {
            if (callback) callback();
            return;
        }
        
        const tempObject = new THREE.Object3D();
        tempObject.position.copy(character.position);
        tempObject.lookAt(targetLookAtPosition);
        const endRotation = tempObject.quaternion.clone();

        if (typeof gsap !== 'undefined' && duration > 0) {
            GAME_STATE.isAnimating = true;
            gsap.to(character.quaternion, {
                _w: endRotation.w, 
                _x: endRotation.x, 
                _y: endRotation.y, 
                _z: endRotation.z,
                duration: duration / 1000,
                ease: "power1.inOut",
                onComplete: () => {
                    GAME_STATE.isAnimating = false;
                    if (callback) callback();
                }
            });
        } else {
            character.quaternion.copy(endRotation);
            if (callback) callback();
        }
    }

    showDiceResult(standard, bonus, total) {
        const display = document.getElementById('dice-result-display');
        const standardEl = document.getElementById('dice-result-standard').querySelector('span');
        const bonusElGroup = document.getElementById('dice-result-bonus');
        const bonusEl = bonusElGroup.querySelector('span');
        const totalEl = display.querySelector('.dice-result-number');

        if (display && standardEl && bonusElGroup && bonusEl && totalEl) {
            standardEl.textContent = standard;
            if (bonus > 0) {
                bonusEl.textContent = bonus;
                bonusElGroup.style.display = 'block';
            } else {
                bonusElGroup.style.display = 'none';
            }
            totalEl.textContent = total;
            display.classList.add('show');
        }
    }

    hideDiceResult() {
        const display = document.getElementById('dice-result-display');
        if (display) {
            display.classList.remove('show');
        }
    }

    handleMovementCompletion(currentTeam, mii, finalPositionIndex) {
        console.log(`[handleMovementCompletion] ${currentTeam.name} ist auf Feld ${finalPositionIndex} gelandet.`);
        this.updateTeamBadgeForTeam(currentTeam.id, finalPositionIndex);

        GAME_STATE.isCharacterMoving = false;
        GAME_STATE.isAnimating = false;
        this.activeMovementAnimation = null;
        console.log(`[handleMovementCompletion] GAME_STATE flags zurückgesetzt für ${currentTeam.name}`);

        if (GAME_STATE.cameraMode === 'follow' && !GAME_STATE.freeCameraMode) {
            this.updateCameraFollow(false);
        } else {
            setTimeout(() => {
                if (GAME_STATE.cameraMode === 'overview' && !GAME_STATE.freeCameraMode) {
                    this.setOverviewCamera(false);
                }
            }, 700);
        }

        if (currentGamePhase === 'ROUND_OVER') {
            this.showStatusMessage("Alle Teams haben gewürfelt. Admin kann nächstes Minispiel setzen.", 4000, 'success');
        } else if (GAME_STATE.currentServerTeamTurnId) {
            const nextTeam = localTeams.find(t => t.id === GAME_STATE.currentServerTeamTurnId);
            if (nextTeam) {
                this.showStatusMessage(`${nextTeam.name} ist am Zug.`, 3000, 'info');
                if (GAME_STATE.cameraMode === 'follow' && !GAME_STATE.freeCameraMode) {
                    setTimeout(() => {
                        this.focusCameraOnCurrentTeam(false);
                    }, 1200);
                }
            }
        } else if (currentGamePhase !== 'DICE_ROLLING' && currentGamePhase !== 'MINIGAME_ANNOUNCED') {
            this.showStatusMessage("Warte auf nächste Aktion vom Admin.", 3000, 'info');
        }
        this.updateTeamDisplay();
    }

    showFieldEffect(position, color, duration = 1000) {
        const effectMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8,
            depthWrite: false
        });
        
        const effectGeometry = new THREE.SphereGeometry(BOARD_CONFIG.fieldRadius * 1.4, 20, 16);
        const effectMesh = new THREE.Mesh(effectGeometry, effectMaterial);
        effectMesh.position.copy(position);
        effectMesh.position.y += BOARD_CONFIG.fieldHeight * 0.6;
        this.scene.add(effectMesh);

        if (typeof gsap !== 'undefined') {
            gsap.to(effectMesh.scale, {
                x: 1.8, y: 1.8, z: 1.8, 
                duration: duration / 1000, 
                ease: "power1.out"
            });
            gsap.to(effectMesh.material, {
                opacity: 0, 
                duration: duration / 1000, 
                ease: "power1.in",
                onComplete: () => {
                    this.scene.remove(effectMesh);
                    effectMesh.geometry.dispose();
                    effectMesh.material.dispose();
                }
            });
        }
    }

    animateCharacterAlongPath(character, pathPoints, onComplete, steps) {
        console.log(`[animateCharacterAlongPath] Animating ${character.uuid} along ${pathPoints.length} points.`);
        if (!character || pathPoints.length === 0) {
            console.warn("[animateCharacterAlongPath] Charakter oder Pfadpunkte fehlen.");
            if (onComplete) onComplete();
            return;
        }

        let currentPointIndex = 0;
        const durationPerStep = 500;
        const turnDuration = 250;

        const moveToNextPoint = () => {
            if (currentPointIndex >= pathPoints.length - 1) {
                console.log(`[animateCharacterAlongPath] Animation für ${character.uuid} beendet.`);
                if (onComplete) onComplete();
                return;
            }

            const startPosition = character.position.clone();
            const endPosition = pathPoints[currentPointIndex + 1];
            const lookAtTarget = (currentPointIndex + 2 < pathPoints.length) ? 
                pathPoints[currentPointIndex + 2] : endPosition;
            
            console.log(`[animateCharacterAlongPath] Schritt ${currentPointIndex + 1}/${pathPoints.length-1}: Zu ${endPosition.x.toFixed(1)},${endPosition.z.toFixed(1)}`);

            this.animateCharacterTurn(character, lookAtTarget, () => {
                if (typeof gsap !== 'undefined') {
                    const tl = gsap.timeline();
                    tl.to(character.position, {
                        x: endPosition.x,
                        z: endPosition.z,
                        duration: durationPerStep / 1000,
                        ease: "power1.inOut"
                    })
                    .to(character.position, {
                        y: endPosition.y + 0.4,
                        duration: (durationPerStep / 1000) / 2,
                        ease: "power1.out"
                    }, "<")
                    .to(character.position, {
                        y: endPosition.y,
                        duration: (durationPerStep / 1000) / 2,
                        ease: "power1.in",
                        onComplete: () => {
                            currentPointIndex++;
                            this.showFieldEffect(character.position, 0x66ff66, 500);
                            moveToNextPoint();
                        }
                    });
                }
            }, turnDuration);
        };

        if (pathPoints.length > 1) {
            moveToNextPoint();
        } else {
            console.log(`[animateCharacterAlongPath] Pfad hat nur ${pathPoints.length} Punkte, keine Bewegung.`);
            if(onComplete) onComplete();
        }
    }

    openTreasureChamberDoor(callback) {
        if(!this.chamberDoor) {
            if(callback) callback();
            return;
        }
        
        const startRotationY = this.chamberDoor.rotation.y;
        const endRotationY = startRotationY - Math.PI / 2.2;
        const duration = 1800;

        if (typeof gsap !== 'undefined') {
            GAME_STATE.isAnimating = true;
            gsap.to(this.chamberDoor.rotation, {
                y: endRotationY,
                duration: duration / 1000,
                ease: "power2.inOut",
                onComplete: () => {
                    GAME_STATE.isAnimating = false;
                    if(callback) callback();
                }
            });
        }
    }

    moveCharacterIntoChamber(character, callback) {
        if(!character || !this.treasureChamber) {
            if(callback) callback();
            return;
        }
        
        const chamberCenter = this.treasureChamber.position.clone();
        const targetPos = chamberCenter.add(new THREE.Vector3(0, BOARD_CONFIG.characterElevation, BOARD_CONFIG.chamberSize * 0.25));

        this.animateCharacterAlongPath(character, [character.position.clone(), targetPos], () => {
            this.animateCharacterTurn(character, chamberCenter.add(new THREE.Vector3(0, 1, -6)), callback, 1000);
        }, 1);
    }

    animateVictory(character, team) {
        this.showStatusMessage(`🎉 ${team.name} hat gewonnen! 🎉`, 10000, 'success');
        this.showVictoryEffect();
        
        if(character.userData.animationVictory) {
            character.userData.animationVictoryActive = true;
        } else {
            if (typeof gsap !== 'undefined') {
                GAME_STATE.isAnimating = true;
                const tl = gsap.timeline({
                    repeat: 8, 
                    yoyo: true, 
                    onComplete: () => GAME_STATE.isAnimating = false
                });
                tl.to(character.position, { 
                    y: "+=1", 
                    duration: 0.4, 
                    ease: "power1.out" 
                })
                .to(character.rotation, { 
                    y: "+=" + Math.PI * 0.75, 
                    duration: 0.4, 
                    ease: "none" 
                }, "<")
                .to(character.position, { 
                    y: "-=1", 
                    duration: 0.4, 
                    ease: "power1.in" 
                });
            }
        }
    }

    showVictoryEffect() {
        // Erstelle Konfetti-Effekt
        for(let i = 0; i < 100; i++) {
            const confettiGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const confettiMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color().setHSL(Math.random(), 0.8, 0.6)
            });
            const confetti = new THREE.Mesh(confettiGeometry, confettiMaterial);
            
            confetti.position.set(
                (Math.random() - 0.5) * 50,
                BOARD_CONFIG.mountainHeight + 30,
                (Math.random() - 0.5) * 50
            );
            
            this.scene.add(confetti);
            
            if (typeof gsap !== 'undefined') {
                gsap.to(confetti.position, {
                    y: -10,
                    duration: 3 + Math.random() * 2,
                    ease: "power2.in",
                    onComplete: () => {
                        this.scene.remove(confetti);
                        confetti.geometry.dispose();
                        confetti.material.dispose();
                    }
                });
                
                gsap.to(confetti.rotation, {
                    x: Math.PI * 4,
                    y: Math.PI * 6,
                    z: Math.PI * 2,
                    duration: 3 + Math.random() * 2,
                    ease: "none"
                });
            }
        }
    }

    updateTeamBadgeForTeam(teamId, position) {
        const teamIndex = localTeams.findIndex(t => t.id === teamId);
        if (teamIndex !== -1) {
            const teamBadge = document.getElementById(`team-badge-${teamId}`);
            if (teamBadge) {
                const positionSpan = teamBadge.querySelector('.team-position');
                if (positionSpan) positionSpan.textContent = `Position: ${position}`;

                const team = localTeams[teamIndex];
                const bonusSpan = teamBadge.querySelector('.team-bonus');
                if (bonusSpan && team) {
                    let bonusText = "0";
                    if (team.bonus_dice_sides == 6) bonusText = "1-6";
                    else if (team.bonus_dice_sides == 4) bonusText = "1-4";
                    else if (team.bonus_dice_sides == 2) bonusText = "1-2";
                    bonusSpan.innerHTML = `Bonus: ${bonusText}`;
                }
            }
        }
    }

    toggleFullscreen() {
        if (!document.fullscreenElement) {
            // Den Canvas-Container in Vollbild versetzen
            const container = document.getElementById('game-canvas-container');
            if (container && container.requestFullscreen) {
                container.requestFullscreen().then(() => {
                    // Nach Vollbild: UI explizit sichtbar machen
                    setTimeout(() => {
                        this.forceUIVisible();
                    }, 200);
                }).catch(err => {
                    this.showStatusMessage(`Fehler Vollbild: ${err.message}`, 4000, 'error');
                });
            } else if (container && container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
                setTimeout(() => this.forceUIVisible(), 200);
            } else if (container && container.mozRequestFullScreen) {
                container.mozRequestFullScreen();
                setTimeout(() => this.forceUIVisible(), 200);
            } else {
                this.showStatusMessage('Vollbild wird nicht unterstützt', 4000, 'error');
            }
            GAME_STATE.isFullscreen = true;
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            GAME_STATE.isFullscreen = false;
        }
        
        // Canvas-Größe nach kurzer Verzögerung aktualisieren
        setTimeout(() => {
            this.updateCanvasSize();
        }, 100);
    }

    forceUIVisible() {
        // UI-Elemente mit maximaler Gewalt sichtbar machen
        const overlay = document.querySelector('.game-overlay');
        if (overlay) {
            overlay.style.cssText = `
                position: fixed !important;
                top: 20px !important;
                left: 20px !important;
                z-index: 2147483647 !important;
                display: flex !important;
                flex-direction: column !important;
                gap: 16px !important;
                opacity: 1 !important;
                visibility: visible !important;
                background: rgba(0,0,0,0.1) !important;
                padding: 10px !important;
                border-radius: 10px !important;
                max-width: 400px !important;
                pointer-events: none !important;
            `;
        }
        
        const currentTeamDisplay = document.querySelector('.current-team-display');
        if (currentTeamDisplay) {
            currentTeamDisplay.style.cssText = `
                display: block !important;
                opacity: 1 !important;
                visibility: visible !important;
                z-index: 2147483647 !important;
                pointer-events: auto !important;
            `;
        }
        
        const teamStatus = document.querySelector('.team-status');
        if (teamStatus) {
            teamStatus.style.cssText = `
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
                z-index: 2147483647 !important;
                pointer-events: auto !important;
            `;
        }

        // Alle Team-Badges einzeln
        document.querySelectorAll('.team-badge').forEach(badge => {
            badge.style.cssText = `
                display: flex !important;
                opacity: 1 !important;
                visibility: visible !important;
                z-index: 2147483647 !important;
                pointer-events: auto !important;
            `;
        });
        
        console.log('[forceUIVisible] UI-Elemente forciert sichtbar gemacht');
    }

    updateCharacterAnimations(time) {
        for (const teamId in this.miiCharacters) {
            const character = this.miiCharacters[teamId];
            if (character && character.userData && typeof character.userData.animation === 'function' && !character.userData.animationVictoryActive) {
                character.userData.animation(time);
            }
            if(character && character.userData && typeof character.userData.animationVictory === 'function' && character.userData.animationVictoryActive) {
                character.userData.animationVictory(time);
            }
        }

        // Schatz-Animationen
        if(this.treasurePile) {
            this.treasurePile.children.forEach(child => {
                if(child.userData && child.userData.animation) {
                    child.userData.animation(time);
                }
            });
        }

        // Kammer-Animationen
        if(this.treasureChamber) {
            this.treasureChamber.children.forEach(child => {
                if(child.type === "Group") {
                    child.children.forEach(part => {
                        if(part.userData.animation) part.userData.animation(time);
                    });
                } else if(child.userData && child.userData.animation) {
                    child.userData.animation(time);
                }
            });
        }

        this.clouds.forEach(cloud => {
            if(cloud.userData.animation) cloud.userData.animation(time);
        });
        
        this.birds.forEach(bird => {
            if(bird.userData.animation) bird.userData.animation(time);
        });
        
        this.particles.forEach(particle => {
            if(particle.userData.animation) particle.userData.animation(time);
        });

        this.boardFields.forEach(fieldData => {
            if(fieldData.mesh) {
                fieldData.mesh.children.forEach(child => {
                    if(child.userData && child.userData.animation) {
                        child.userData.animation(time);
                    }
                });
            }
        });
    }

    updateMinigameDisplay() {
        const nameEl = document.getElementById('minigame-name');
        const descEl = document.getElementById('minigame-description');
        const displayEl = document.getElementById('minigame-info-display');

        if (nameEl && descEl && displayEl) {
            if (currentMinigameName && (currentGamePhase === 'MINIGAME_ANNOUNCED' || currentGamePhase === 'DICE_ROLLING')) {
                nameEl.textContent = currentMinigameName;
                descEl.textContent = currentMinigameDescription || "Macht euch bereit!";
                displayEl.style.display = 'block';
            } else {
                displayEl.style.display = 'none';
            }
        }
    }

    fetchBoardStatusAndUpdate() {
        if (GAME_STATE.isCharacterMoving) {
            // Keine Kommentierung - kann wichtige Updates verhindern
        }

        fetch("{{ url_for('main.board_status') }}?t=" + new Date().getTime())
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errData => {
                        console.error("Server error JSON:", errData);
                        throw new Error(errData.error || errData.details || `Serverfehler: ${response.status}`);
                    }).catch(() => {
                        throw new Error(`Serverfehler: ${response.status} - ${response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    console.error("Server-Fehler (API):", data.error, data.details);
                    this.showStatusMessage(`Serverproblem: ${data.error}`, 5000, 'error');
                    if (data.details) console.error("Server-Traceback:", data.details);
                    return;
                }

                if (data.game_session) {
                    let minigameInfoChanged = false;
                    if (currentMinigameName !== data.game_session.current_minigame_name ||
                        currentMinigameDescription !== data.game_session.current_minigame_description ||
                        currentGamePhase !== data.game_session.current_phase) {
                        minigameInfoChanged = true;
                    }
                    
                    currentMinigameName = data.game_session.current_minigame_name;
                    currentMinigameDescription = data.game_session.current_minigame_description;
                    currentGamePhase = data.game_session.current_phase;

                    if(minigameInfoChanged) {
                        this.updateMinigameDisplay();
                    }

                    GAME_STATE.currentServerTeamTurnId = data.game_session.current_team_turn_id;
                    
                    if (typeof data.game_session.dice_roll_order === 'string' && data.game_session.dice_roll_order.length > 0) {
                        GAME_STATE.diceRollOrderFromServer = data.game_session.dice_roll_order.split(',');
                    } else if (Array.isArray(data.game_session.dice_roll_order)) {
                        GAME_STATE.diceRollOrderFromServer = data.game_session.dice_roll_order;
                    } else {
                        GAME_STATE.diceRollOrderFromServer = [];
                    }

                    if (data.teams && Array.isArray(data.teams)) {
                        let teamWhosePositionChanged = null;
                        let newPositionForAnimation = 0;
                        let oldPositionForAnimation = 0;

                        data.teams.forEach(serverTeam => {
                            const localTeam = localTeams.find(t => t.id === serverTeam.id);
                            if (localTeam) {
                                if (localTeam.position !== serverTeam.position &&
                                    !GAME_STATE.isCharacterMoving &&
                                    (!this.activeMovementAnimation || this.activeMovementAnimation.teamId !== localTeam.id)
                                ) {
                                    console.log(`[fetchBoardStatusAndUpdate] Position für Team ${localTeam.name} geändert: Alt=${localTeam.position}, Neu=${serverTeam.position}. Animation wird vorbereitet.`);
                                    teamWhosePositionChanged = localTeam;
                                    oldPositionForAnimation = localTeam.position;
                                    newPositionForAnimation = serverTeam.position;
                                }
                                
                                localTeam.position = serverTeam.position;
                                localTeam.bonus_dice_sides = serverTeam.bonus_dice_sides;
                                localTeam.minigame_placement = serverTeam.minigame_placement;
                            }
                        });

                        this.updateAllTeamBadges();

                        if (teamWhosePositionChanged && this.miiCharacters[teamWhosePositionChanged.id]) {
                            if (this.activeMovementAnimation && this.activeMovementAnimation.teamId === teamWhosePositionChanged.id) {
                                console.log("[fetchBoardStatusAndUpdate] Bewegungsanimation für Team", teamWhosePositionChanged.name, "läuft bereits oder ist gerade beendet. Überspringe erneute Animation.");
                            } else if (!GAME_STATE.isCharacterMoving) {
                                console.log(`[fetchBoardStatusAndUpdate] Starte Animation für ${teamWhosePositionChanged.name}.`);
                                this.activeMovementAnimation = { teamId: teamWhosePositionChanged.id };
                                this.animateCharacterToNewPosition(teamWhosePositionChanged, oldPositionForAnimation, newPositionForAnimation);
                            } else {
                                console.log(`[fetchBoardStatusAndUpdate] Animation für ${teamWhosePositionChanged.name} nicht gestartet, da GAME_STATE.isCharacterMoving=true.`);
                            }
                        } else if (teamWhosePositionChanged) {
                            console.warn("[fetchBoardStatusAndUpdate] Charakter-Mesh für Bewegung nicht gefunden:", teamWhosePositionChanged.name);
                            this.activeMovementAnimation = null;
                            this.handleMovementCompletion(teamWhosePositionChanged, null, newPositionForAnimation);
                        }
                    }
                    this.updateTeamDisplay();
                } else {
                    console.warn("[fetchBoardStatusAndUpdate] Keine game_session Daten vom Server empfangen.");
                    currentGamePhase = 'UNKNOWN_NO_SESSION';
                    currentMinigameName = null;
                    currentMinigameDescription = null;
                    this.updateMinigameDisplay();
                    this.updateTeamDisplay();
                }
            })
            .catch(error => {
                console.error("[fetchBoardStatusAndUpdate] Fehler beim Abrufen/Verarbeiten des Board-Status:", error.message, error);
                this.showStatusMessage(`Verbindungsproblem: ${error.message}`, 3000, "error");
                currentGamePhase = 'ERROR_FETCH';
                this.updateMinigameDisplay();
                this.updateTeamDisplay();
            });
    }

    updateAllTeamBadges() {
        localTeams.forEach(team => {
            this.updateTeamBadgeForTeam(team.id, team.position);
        });
    }

    async loadCharacterScript(jsPath) {
        let rawFunctionName = jsPath.split('/').pop().replace(/\.js$/, '');
        let functionName = rawFunctionName;

        if (rawFunctionName === 'defaultCharacter') {
            functionName = 'createDefaultCharacter';
        } else if (!rawFunctionName.toLowerCase().startsWith('create')) {
            functionName = 'create' + rawFunctionName.charAt(0).toUpperCase() + rawFunctionName.slice(1);
        }

        console.log(`[loadCharacterScript] Lade Skript: ${jsPath}, erwarte Funktion: window.${functionName}`);

        if (this.characterCreationFunctions[functionName]) {
            console.log(`[loadCharacterScript] Funktion ${functionName} bereits geladen und gecached.`);
            return this.characterCreationFunctions[functionName];
        }

        const fallbackCreateFunction = window.createDefaultCharacter;
        if (typeof fallbackCreateFunction !== 'function') {
            console.error("[loadCharacterScript] FATAL: window.createDefaultCharacter ist nicht global verfügbar!");
            return () => new THREE.Mesh(
                new THREE.BoxGeometry(0.5, 1, 0.5), 
                new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true})
            );
        }

        return new Promise((resolve) => {
            if (!jsPath || jsPath.trim() === "") {
                console.warn("[loadCharacterScript] Leerer jsPath, verwende Default Charakter.");
                resolve(fallbackCreateFunction);
                return;
            }
            
            const script = document.createElement('script');
            script.src = `{{ url_for('static', filename='') }}${jsPath}?v=${new Date().getTime()}`;
            console.log(`[loadCharacterScript] Setze script.src zu: ${script.src}`);

            script.onload = () => {
                console.log(`[loadCharacterScript] Skript ${jsPath} geladen. Prüfe auf window.${functionName}`);
                if (typeof window[functionName] === 'function') {
                    console.log(`[loadCharacterScript] Funktion ${functionName} erfolgreich gefunden.`);
                    this.characterCreationFunctions[functionName] = window[functionName];
                    resolve(window[functionName]);
                } else {
                    console.error(`[loadCharacterScript] Charakter-Erstellungsfunktion ${functionName} NICHT im window-Objekt gefunden nach Laden von ${jsPath}. Verwende Default.`);
                    console.log(`[loadCharacterScript] Verfügbare Funktionen im window-Objekt, die mit "create" beginnen:`, Object.keys(window).filter(k => k.startsWith("create")));
                    resolve(fallbackCreateFunction);
                }
            };
            
            script.onerror = (e) => {
                console.error(`[loadCharacterScript] Fehler beim Laden des Charakter-Skripts ${jsPath}:`, e, ". Verwende Default.");
                resolve(fallbackCreateFunction);
            };
            
            document.head.appendChild(script);
        });
    }

    async createMiiCharacters() {
        console.log("[WiiPartyIsland] createMiiCharacters: Start");
        
        if (typeof window.createDefaultCharacter !== 'function') {
            console.warn('[createMiiCharacters] window.createDefaultCharacter nicht sofort verfügbar. Versuche, es explizit zu laden.');
            try {
                await this.loadCharacterScript('js/characters/defaultCharacter.js');
                if (typeof window.createDefaultCharacter !== 'function') {
                    console.error('[createMiiCharacters] Konnte window.createDefaultCharacter auch nach explizitem Laden nicht finden. Breche Charaktererstellung ab.');
                    return;
                }
            } catch (e) {
                console.error('[createMiiCharacters] Fehler beim Laden von defaultCharacter.js:', e);
                return;
            }
        }

        for (const team of localTeams) {
            let createFunction;
            let characterJsFile = "js/characters/defaultCharacter.js";

            if (team.character_info && team.character_info.js_file && team.character_info.js_file.trim() !== "") {
                characterJsFile = team.character_info.js_file;
            } else {
                console.warn(`[createMiiCharacters] Keine Charakter-Info (js_file) für Team ${team.name}, verwende Default-Charakter-Skript: ${characterJsFile}`);
            }

            console.log(`[createMiiCharacters] Lade Charakter für Team ${team.name} mit Skript: ${characterJsFile}`);
            try {
                createFunction = await this.loadCharacterScript(characterJsFile);
            } catch (error) {
                console.error(`[createMiiCharacters] Fehler beim Laden des Skripts ${characterJsFile} für Team ${team.name}:`, error, ". Verwende Default.");
                createFunction = window.createDefaultCharacter;
            }

            if (typeof createFunction !== 'function') {
                console.error(`[createMiiCharacters] createFunction für Team ${team.name} ist keine Funktion, verwende Default. Erhalten:`, createFunction, `Erwartet von Skript: ${characterJsFile}`);
                createFunction = window.createDefaultCharacter;
            }
            
            if (typeof createFunction !== 'function' && typeof window.createDefaultCharacter === 'function') {
                console.warn(`[createMiiCharacters] Fallback zu window.createDefaultCharacter, da createFunction ungültig war.`);
                createFunction = window.createDefaultCharacter;
            } else if (typeof createFunction !== 'function') {
                console.error(`[createMiiCharacters] FATAL: Auch window.createDefaultCharacter ist keine Funktion. Kann keine Charaktere erstellen für Team ${team.name}.`);
                continue;
            }

            const characterMesh = createFunction(team.color || '#CCCCCC');
            if (!characterMesh || typeof characterMesh.scale === 'undefined') {
                console.error(`[createMiiCharacters] Die Funktion ${createFunction.name} für ${team.name} hat kein gültiges Three.js Objekt zurückgegeben. Verwende stattdessen Default.`);
                this.miiCharacters[team.id] = window.createDefaultCharacter(team.color || '#CCCCCC');
                if(this.miiCharacters[team.id]) {
                    this.miiCharacters[team.id].scale.setScalar(BOARD_CONFIG.characterSize);
                } else {
                    console.error(`[createMiiCharacters] Konnte auch kein Default-Mesh für ${team.name} erstellen.`);
                    continue;
                }
            } else {
                this.miiCharacters[team.id] = characterMesh;
                this.miiCharacters[team.id].scale.setScalar(BOARD_CONFIG.characterSize);
            }

            this.miiCharacters[team.id].castShadow = true;
            this.miiCharacters[team.id].receiveShadow = true;
            this.miiCharacters[team.id].traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });

            const startField = this.boardFields[team.position];
            if (startField && startField.mesh) {
                this.miiCharacters[team.id].position.copy(startField.mesh.position);
                this.miiCharacters[team.id].position.y += BOARD_CONFIG.characterElevation;
            } else {
                this.miiCharacters[team.id].position.set(
                    BOARD_CONFIG.spiralStartRadius + (Math.random()-0.5)*2, 
                    islandSurfaceY + BOARD_CONFIG.characterElevation, 
                    (Math.random()-0.5)*2
                );
                console.warn(`[createMiiCharacters] Startfeld für Team ${team.name} (Position ${team.position}) nicht gefunden. Setze auf Default-Position.`);
            }
            
            this.scene.add(this.miiCharacters[team.id]);
            console.log(`[createMiiCharacters] Charakter für Team ${team.name} (Funktion: ${createFunction ? createFunction.name : 'unbekannt'}) erstellt und zu Szene hinzugefügt.`);
        }
        
        this.updateTeamDisplay();
        if(!GAME_STATE.freeCameraMode) this.setOverviewCamera(true);
        console.log("[WiiPartyIsland] createMiiCharacters: Beendet. Mii-Charaktere:", this.miiCharacters);
    }

    animateCharacterToNewPosition(team, oldPositionIndex, newPositionIndex) {
        const mii = this.miiCharacters[team.id];
        console.log(`[animateCharacterToNewPosition] Aufgerufen für ${team.name} von ${oldPositionIndex} zu ${newPositionIndex}. Mii vorhanden: ${!!mii}`);

        if (!mii) {
            console.warn(`[animateCharacterToNewPosition] Kein Mii-Objekt für Team ${team.name} (ID: ${team.id}) gefunden.`);
            this.handleMovementCompletion(team, null, newPositionIndex);
            return;
        }
        
        if (oldPositionIndex === newPositionIndex) {
            console.log(`[animateCharacterToNewPosition] ${team.name} ist bereits auf Position ${newPositionIndex}. Keine Bewegung.`);
            const targetField = this.boardFields[newPositionIndex];
            if (targetField && targetField.mesh) {
                mii.position.copy(targetField.mesh.position);
                mii.position.y += BOARD_CONFIG.characterElevation;
            }
            this.handleMovementCompletion(team, mii, newPositionIndex);
            return;
        }

        console.log(`[animateCharacterToNewPosition] Starte Animation für ${team.name} von ${oldPositionIndex} zu ${newPositionIndex}`);
        GAME_STATE.isCharacterMoving = true;
        GAME_STATE.isAnimating = true;
        console.log(`[animateCharacterToNewPosition] GAME_STATE.isCharacterMoving set to true for ${team.name}`);

        const pointsToMove = [];
        const startIdx = Math.min(this.boardFields.length - 1, Math.max(0, oldPositionIndex));
        const endIdx = Math.min(this.boardFields.length - 1, Math.max(0, newPositionIndex));

        if (startIdx < endIdx) {
            for (let i = startIdx; i <= endIdx; i++) {
                if (this.boardFields[i] && this.boardFields[i].mesh) {
                    const fieldPos = this.boardFields[i].mesh.position.clone();
                    fieldPos.y += BOARD_CONFIG.characterElevation;
                    pointsToMove.push(fieldPos);
                } else {
                    console.warn(`[animateCharacterToNewPosition] Feld ${i} nicht gefunden für Pfad.`);
                }
            }
        } else if (startIdx > endIdx) {
            for (let i = startIdx; i >= endIdx; i--) {
                if (this.boardFields[i] && this.boardFields[i].mesh) {
                    const fieldPos = this.boardFields[i].mesh.position.clone();
                    fieldPos.y += BOARD_CONFIG.characterElevation;
                    pointsToMove.push(fieldPos);
                } else {
                    console.warn(`[animateCharacterToNewPosition] Feld ${i} nicht gefunden für Pfad.`);
                }
            }
        } else {
            console.log(`[animateCharacterToNewPosition] Start- und Endindex sind gleich (${startIdx}), keine Bewegungspunkte generiert.`);
            this.handleMovementCompletion(team, mii, newPositionIndex);
            return;
        }

        if (pointsToMove.length === 0) {
            console.warn("[animateCharacterToNewPosition] Keine Bewegungspunkte für Animation generiert.", team.name, oldPositionIndex, newPositionIndex);
            this.handleMovementCompletion(team, mii, newPositionIndex);
            return;
        }

        let animationPath = [];
        if (mii.position.distanceTo(pointsToMove[0]) > 0.1) {
            animationPath.push(mii.position.clone());
        }
        animationPath = animationPath.concat(pointsToMove);

        if (animationPath.length > 0) {
            console.log(`[animateCharacterToNewPosition] Animationpfad für ${team.name} hat ${animationPath.length} Punkte.`);
            const onMovementComplete = () => {
                console.log(`[animateCharacterToNewPosition] Bewegung für ${team.name} abgeschlossen. Rufe handleMovementCompletion.`);
                this.handleMovementCompletion(team, mii, newPositionIndex);
            };

            if (GAME_STATE.cameraMode === 'follow' && !GAME_STATE.freeCameraMode) {
                this.focusCameraOnCurrentTeam(false, () => {
                    this.animateCharacterAlongPath(mii, animationPath, onMovementComplete, Math.abs(endIdx - startIdx));
                });
            } else {
                this.animateCharacterAlongPath(mii, animationPath, onMovementComplete, Math.abs(endIdx - startIdx));
            }
        } else {
            console.warn(`[animateCharacterToNewPosition] Leerer Animationspfad für ${team.name}.`);
            this.handleMovementCompletion(team, mii, newPositionIndex);
        }
    }

    animate() {
        requestAnimationFrame(this.animate);
        const time = Date.now() * 0.001;

        // Wasseranimation
        if (this.water && this.water.userData && this.water.userData.animation) {
            this.water.userData.animation(time);
        }

        // Verbesserte Kamerasteuerung
        if (GAME_STATE.freeCameraMode && this.controls) {
            this.controls.update();
        } else if (this.isFollowingCharacter && this.followTarget && !GAME_STATE.isAnimatingCamera) {
            const now = Date.now();
            if (now - this.lastCameraUpdate > 80) {
                const targetPos = this.followTarget.position.clone();
                const camOffset = BOARD_CONFIG.cameraFollowOffset.clone();
                const desiredCamPos = targetPos.clone().add(camOffset);
                const lookAtPos = targetPos.clone().add(new THREE.Vector3(0, 2.5, 0));

                this.camera.position.lerp(desiredCamPos, 0.04);
                this.controls.target.lerp(lookAtPos, 0.04);
                this.camera.lookAt(this.controls.target);
                this.lastCameraUpdate = now;
            }
        }

        this.updateCharacterAnimations(time);

        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }
}

document.addEventListener('DOMContentLoaded', function() {
    console.log("[DOMContentLoaded] Event gefeuert.");

    const canvasElement = document.getElementById('game-canvas');
    const canvasContainer = document.getElementById('game-canvas-container');

    if (canvasElement && canvasContainer) {
        if (localTeams && localTeams.length > 0) {
            console.log("[DOMContentLoaded] Teams vorhanden, initialisiere WiiPartyIsland.");
            try {
                window.gameBoardInstance = new WiiPartyIsland('game-canvas');
            } catch (e) {
                console.error("[DOMContentLoaded] Kritischer Fehler bei 'new WiiPartyIsland':", e);
                canvasContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Kritischer Fehler beim Erstellen des Spielbretts. Details in der Konsole.</p>";
            }
        } else {
            console.log("[DOMContentLoaded] Keine Teams vorhanden.");
            let message = "";
            if (isAdmin) {
                message = "Noch keine Teams angelegt. Bitte im <a href='{{ url_for('admin.admin_dashboard') }}'>Admin Dashboard</a> Teams erstellen, um das Spielbrett zu sehen.";
            } else {
                message = "Warte auf Spieler oder starte ein neues Spiel. Das Spielbrett wird angezeigt, sobald Teams vorhanden sind.";
            }
            canvasContainer.innerHTML = `<p style='color:#333; text-align:center; padding-top: 50px; font-size:1.2em;'>${message}</p>`;
        }
    } else {
        console.error("[DOMContentLoaded] Canvas-Element ('game-canvas') oder Container ('game-canvas-container') nicht gefunden.");
        if(canvasContainer) {
            canvasContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Fehler: Canvas-Element für Spielbrett nicht gefunden.</p>";
        } else if (document.body) {
            document.body.insertAdjacentHTML('afterbegin', "<p style='color:red; text-align:center; padding: 50px;'>Fehler: Wichtige Seitenelemente für das Spielbrett fehlen.</p>");
        }
    }
});
</script>

{% endblock %}