{% extends "base.html" %}

{% block title %}Insel der Abenteuer{% endblock %}

{% block content %}

<div class="game-container">
    <div id="game-canvas-container">
        <canvas id="game-canvas"></canvas>
        
        <div class="game-overlay">
            <div class="current-team-display">
                <h4>Am Zug: <span id="current-team">-</span></h4>
            </div>
            
            <div class="team-status">
                {% if teams %}
                    {% for team in teams %}
                    <div class="team-badge" style="background-color: {{ team_colors[loop.index0 % team_colors|length] }};">
                        <span class="team-name">{{ team.name }}</span>
                        <span class="team-position">Position: {{ team.current_position if team.current_position is not none else 0 }}</span>
                    </div>
                    {% endfor %}
                {% else %}
                    {% if is_admin %}
                        <p class="text-muted p-2">Noch keine Teams angelegt. Bitte im <a href='{{ url_for('admin.admin_dashboard') }}'>Admin Dashboard</a> Teams erstellen, um das Spielbrett zu sehen.</p>
                    {% else %}
                        <p class="text-muted p-2">Warte auf Spieler oder starte ein neues Spiel.</p>
                    {% endif %}
                {% endif %}
            </div>
            
            {% if teams and (is_admin or (current_user.is_authenticated and not current_user.is_admin)) %}
            <div class="admin-controls">               
                <button id="roll-dice" class="btn btn-primary">Würfeln</button>
                <div class="help-text">
                    Drücke <kbd>M</kbd> für freie Kamera, <kbd>F</kbd> für Vollbild
                </div>
            </div>
            {% endif %}
        </div>
        
        <div id="dice-result-display" class="dice-result-display">
            <div class="dice-result-number">6</div>
            <div class="dice-result-text">Felder</div>
        </div>
    </div>
</div>

{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

{# Pfade zu deinen Charakter-JS-Dateien #}
<script src="{{ url_for('static', filename='js/characters/tungTungTungSahur.js') }}"></script>
<script src="{{ url_for('static', filename='js/characters/ballerinaCappuccina.js') }}"></script>
<script src="{{ url_for('static', filename='js/characters/bombardinoCrocodilo.js') }}"></script>
<script src="{{ url_for('static', filename='js/characters/liriliLarila.js') }}"></script>
<script src="{{ url_for('static', filename='js/characters/tralaleroTralala.js') }}"></script>
<script src="{{ url_for('static', filename='js/characters/trippiTroppi.js') }}"></script>
<script src="{{ url_for('static', filename='js/characters/defaultCharacter.js') }}"></script>

<script>
// Spielbrett-Konfiguration
const BOARD_CONFIG = { 
    fieldTypes: { start: { color: 0x4FC3F7, emission: 0x002244, name: 'Start' }, normal: { color: 0x81C784, emission: 0x001122, name: 'Normales Feld' }, bonus: { color: 0xFFD54F, emission: 0x442200, name: 'Bonusfeld' }, chance: { color: 0xAED581, emission: 0x224400, name: 'Ereignisfeld' }, trap: { color: 0xE57373, emission: 0x440000, name: 'Falle' }, minigame: { color: 0xBA68C8, emission: 0x440044, name: 'Minispiel' }, goal: { color: 0xFFB74D, emission: 0x442200, name: 'Ziel' } }, fieldSize: 1.0, fieldHeight: 0.25, fieldRadius: 0.55, pathWidth: 2.8, pathSegmentBaseDepth: 0.25, pathColor: 0xD7CCC8, pathBorderColor: 0xBCAAA4, characterElevation: 0.4, characterSize: 0.4, mountainHeight: 20, mountainBaseRadius: 17, mountainTopRadius: 2.5, spiralHeight: 18, spiralStartRadius: 20, spiralLoops: 2.6, pathDepth: 4.5, chamberSize: 7.0, cameraFollowOffset: new THREE.Vector3(0, 7, 12), cameraFrontOffset: new THREE.Vector3(0, 4, -8) };
const islandSurfaceY = 1.8;
const GAME_STATE = { currentTeamIndex: 0, isAnimating: false, isDiceRolling: false, isCharacterMoving: false, diceResult: 0, freeCameraMode: false, isFullscreen: false, isAnimatingCamera: false, characterTurnSpeed: 0.08, playerTurnInProgress: false, cameraMode: 'front' };

const teams = [
    {% for team in teams %}
    {
        id: {{ team.id }},
        name: "{{ team.name | e }}",
        position: {{ team.current_position if team.current_position is not none else 0 }},
        color: "{{ team_colors[loop.index0 % team_colors|length] }}",
        character_info: {% if team.character_name %}
        {
            name: "{{ team.character_name | e }}",
            image_path: "{{ team.character_image | e if team.character_image else '' }}"
        }
        {% else %}
        null
        {% endif %}
    }{% if not loop.last %},{% endif %}
    {% endfor %}
];
console.log("Initial teams array from Jinja:", JSON.parse(JSON.stringify(teams)));


class WiiPartyIsland {
    constructor(canvasId) {
        console.log("[WiiPartyIsland] Constructor: Start");
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            console.error("[WiiPartyIsland] FEHLER: Canvas-Element mit ID '" + canvasId + "' nicht gefunden!");
            return; 
        }

        // Methoden binden
        this.updateCanvasSize = this.updateCanvasSize.bind(this);
        this.animate = this.animate.bind(this);
        this.setupEventListeners = this.setupEventListeners.bind(this);
        this.rollDice = this.rollDice.bind(this); 

        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(50, this.canvas.clientWidth / Math.max(1, this.canvas.clientHeight), 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.2;
        
        console.log("[WiiPartyIsland] Renderer und Kamera initialisiert.");
        this.updateCanvasSize(); 
        
        this.camera.position.set(25, 25, 25);
        this.camera.lookAt(0, 5, 0);
        
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true; this.controls.dampingFactor = 0.05;
        this.controls.minDistance = 5; this.controls.maxDistance = 80;
        this.controls.maxPolarAngle = Math.PI / 1.8; this.controls.target.set(0, 8, 0);
        this.controls.enabled = false;
        
        this.pathPoints = []; this.boardFields = []; this.miiCharacters = {};
        this.activeCharacterPath = null; this.raycaster = new THREE.Raycaster();
        this.interactiveDice = null; this.island = null; this.mountainMesh = null;
        this.chamberDoor = null; this.water = null; this.clouds = []; this.birds = [];
        this.isFollowingCharacter = false; this.followTarget = null;

        console.log("[WiiPartyIsland] Constructor: Basisinitialisierung abgeschlossen, rufe init()");
        this.init(); 
    }
    
    // *** VOLLSTÄNDIGE METHODENDEKLARATIONEN BEGINNEN HIER ***
    
    updateCanvasSize() {
        console.log("[WiiPartyIsland] Methode updateCanvasSize() wird ausgeführt."); 
        const container = document.getElementById('game-canvas-container');
        if (!container) { console.warn("[WiiPartyIsland] Canvas-Container nicht gefunden."); return; }
        const rect = container.getBoundingClientRect();
        const width = Math.max(1, rect.width); const height = Math.max(1, rect.height);
        if (this.renderer) { this.renderer.setSize(width, height, false); }
        if (this.camera) { this.camera.aspect = width / height; this.camera.updateProjectionMatrix(); }
    }

    async init() {
        console.log("[WiiPartyIsland] init(): Start");
        this.setupLighting();
        this.createOcean();
        this.createIslandAndMountain(); 
        
        console.log("[WiiPartyIsland] DEBUG: Vor Aufruf von this.createSpiralPath(). typeof this.createSpiralPath:", typeof this.createSpiralPath);
        if (typeof this.createSpiralPath !== 'function') {
            console.error("[WiiPartyIsland] FATAL: this.createSpiralPath ist KEINE Funktion!", this);
            return; 
        }
        this.createSpiralPath();
        
        this.createVegetation();      
        this.createTreasureChamber(); 
        if (teams && teams.length > 0) {
            this.createMiiCharacters();   
        }
        this.createEnvironmentalDetails(); 
        this.createInteractiveDice(); 
        
        console.log("[WiiPartyIsland] DEBUG: Vor Aufruf von this.setupEventListeners(). typeof this.setupEventListeners:", typeof this.setupEventListeners);
        if (typeof this.setupEventListeners !== 'function') {
            console.error("[WiiPartyIsland] FATAL: this.setupEventListeners ist KEINE Funktion!", this);
            return;
        }
        this.setupEventListeners();

        console.log("[WiiPartyIsland] DEBUG: Vor Aufruf von this.animate(). typeof this.animate:", typeof this.animate);
        if (typeof this.animate !== 'function') {
            console.error("[WiiPartyIsland] FATAL: this.animate ist KEINE Funktion!", this);
            return;
        }
        this.animate(); 

        this.updateTeamDisplay(); 
        
        if (teams && teams.length > 0) {
            this.prepareNextPlayerTurn(true); 
        }
        console.log("[WiiPartyIsland] init(): Beendet");
    }
    
    setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(50, 70, 40);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; 
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        this.scene.add(sunLight);
        this.scene.background = new THREE.Color(0x87CEEB); 
        this.scene.fog = new THREE.Fog(0xb3d9ff, 80, 200); 
    }
            
    createOcean() {
        const oceanRadius = 120;
        const waterGeometry = new THREE.PlaneGeometry(oceanRadius * 2, oceanRadius * 2, 128, 128);
        const positions = waterGeometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const z = positions[i + 2];
            const distance = Math.sqrt(x * x + z * z);
            if (distance > 35) { 
                positions[i + 1] = Math.sin(x * 0.06) * 0.3 + Math.sin(z * 0.08) * 0.3;
            } else { 
                positions[i + 1] = Math.sin(x * 0.12) * 0.1 + Math.sin(z * 0.12) * 0.1;
            }
        }
        waterGeometry.attributes.position.needsUpdate = true;
        waterGeometry.computeVertexNormals();
        const waterMaterial = new THREE.MeshPhongMaterial({
            color: 0x4DD0E1, 
            specular: 0xB0BEC5, 
            shininess: 80,
            transparent: true,
            opacity: 0.9
        });
        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -0.4; 
        water.receiveShadow = true;
        this.scene.add(water);
        water.userData = {
            animation: time => {
                const positions = water.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i+2];
                    const distance = Math.sqrt(x * x + z * z);
                    if (distance > 35) {
                        positions[i + 1] = Math.sin(x * 0.06 + time * 0.8) * 0.3 + 
                                         Math.sin(z * 0.08 + time * 0.6) * 0.3;
                    } else {
                        positions[i + 1] = Math.sin(x * 0.12 + time * 0.5) * 0.1 + 
                                         Math.sin(z * 0.12 + time * 0.7) * 0.1;
                    }
                }
                water.geometry.attributes.position.needsUpdate = true;
                water.geometry.computeVertexNormals();
            }
        };
        this.water = water;
    }

    createIslandAndMountain() {
        const islandGeometry = new THREE.CylinderGeometry(28, 30, 3.6, 64, 1, false);
        const islandPositions = islandGeometry.attributes.position.array;
        for (let i = 0; i < islandPositions.length; i += 3) {
            const x = islandPositions[i];
            const z = islandPositions[i + 2];
            const distance = Math.sqrt(x * x + z * z);
            if (distance > 22) {
                const waveHeight = Math.sin(distance * 0.4) * 0.3 + Math.cos(distance * 0.2) * 0.2;
                islandPositions[i + 1] += waveHeight;
            }
        }
        islandGeometry.attributes.position.needsUpdate = true;
        islandGeometry.computeVertexNormals();
        const islandMaterial = new THREE.MeshPhongMaterial({ color: 0xF5DEB3, shininess: 5 });
        this.island = new THREE.Mesh(islandGeometry, islandMaterial);
        this.island.position.y = 0;
        this.island.receiveShadow = true;
        this.island.castShadow = true;
        this.scene.add(this.island);
        this.createIslandVegetation();
        this.createMountainWithPath();
    }
    
    createIslandVegetation() {
        const baseIslandTopY = islandSurfaceY;
        const layers = [
            { radius: 26, height: 0.15, color: 0x4CAF50 }, 
            { radius: 24, height: 0.1, color: 0x66BB6A }  
        ];
        let currentPlacementY = baseIslandTopY;
        layers.forEach((layer) => {
            const vegGeometry = new THREE.CylinderGeometry(
                layer.radius, layer.radius + 0.2, layer.height, 32 
            );
            const vegMaterial = new THREE.MeshLambertMaterial({ color: layer.color });
            const vegetation = new THREE.Mesh(vegGeometry, vegMaterial);
            vegetation.position.y = currentPlacementY + layer.height * 0.5;
            currentPlacementY += layer.height;
            vegetation.receiveShadow = true;
            this.scene.add(vegetation);
        });
    }

    createMountainWithPath() {
        this.calculatePathPoints(); 
        const detail = 256; 
        const mountainGeometry = new THREE.BufferGeometry();
        const vertices = []; const indices = []; const uvs = [];
        const flatTopRadius = BOARD_CONFIG.mountainTopRadius * 0.85;
        const mountainFootY = islandSurfaceY;

        for (let i = 0; i <= detail; i++) {
            for (let j = 0; j <= detail; j++) {
                const x = (i / detail - 0.5) * BOARD_CONFIG.mountainBaseRadius * 2.2;
                const z = (j / detail - 0.5) * BOARD_CONFIG.mountainBaseRadius * 2.2;
                const distance = Math.sqrt(x * x + z * z);
                let y_shape = 0;
                if (distance <= BOARD_CONFIG.mountainBaseRadius) {
                    if (distance <= flatTopRadius) {
                        y_shape = BOARD_CONFIG.mountainHeight + (Math.random() * 0.05);
                    } else {
                        const progress = (distance - flatTopRadius) / (BOARD_CONFIG.mountainBaseRadius - flatTopRadius);
                        const smoothProgress = 1 - (progress * progress * (3 - 2 * progress)); 
                        y_shape = BOARD_CONFIG.mountainHeight * smoothProgress;
                        y_shape += (Math.sin(x * 1.2) * Math.cos(z * 1.2)) * 0.2 * (1 - smoothProgress);
                        y_shape += (Math.random() - 0.5) * 0.3 * (1 - smoothProgress);
                    }
                    const pathInfluence = this.getPathInfluence(x, z);
                    if (pathInfluence > 0) {
                        const pathHeightAbsolute = this.getInterpolatedPathHeight(x, z);
                        const pathHeightRelativeToMountainFoot = pathHeightAbsolute - mountainFootY;
                        const rinnenTiefe = BOARD_CONFIG.pathDepth * pathInfluence * 0.3; 
                        y_shape = Math.max(y_shape - rinnenTiefe, pathHeightRelativeToMountainFoot - rinnenTiefe * 0.2);
                    }
                } else if (distance <= BOARD_CONFIG.mountainBaseRadius * 1.15) { 
                    const fadeOut = 1 - ((distance - BOARD_CONFIG.mountainBaseRadius) / (BOARD_CONFIG.mountainBaseRadius * 0.15));
                    y_shape = fadeOut * 0.08 - 0.05; 
                } else {
                    y_shape = -0.05; 
                }
                vertices.push(x, mountainFootY + y_shape, z);
                uvs.push(i / detail, j / detail);
            }
        }
        for (let i = 0; i < detail; i++) {
            for (let j = 0; j < detail; j++) {
                const a = i * (detail + 1) + j; const b = a + 1;
                const c = a + detail + 1; const d = c + 1;
                indices.push(a, b, c); indices.push(b, d, c);
            }
        }
        mountainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        mountainGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        mountainGeometry.setIndex(indices);
        mountainGeometry.computeVertexNormals();
        const mountainMaterial = new THREE.MeshPhongMaterial({ vertexColors: true, map: null, shininess: 8 });
        const mountainColorAttr = new Float32Array(vertices.length);
        for (let k_color = 0; k_color < vertices.length; k_color += 3) {
            const yPos = vertices[k_color + 1];
            const height = Math.max(0, Math.min(1, (yPos - mountainFootY) / BOARD_CONFIG.mountainHeight));
            let r, g, b;
            if (height < 0.1) { r = 0.3; g = 0.4; b = 0.2; } 
            else if (height < 0.6) { r = 0.2; g = 0.6; b = 0.1; } 
            else if (height < 0.85) { r = 0.5; g = 0.5; b = 0.4; } 
            else { r = 0.9; g = 0.9; b = 0.95; }
            mountainColorAttr[k_color] = r; mountainColorAttr[k_color+1] = g; mountainColorAttr[k_color+2] = b;
        }
        mountainGeometry.setAttribute('color', new THREE.Float32BufferAttribute(mountainColorAttr, 3));
        const mountainMesh = new THREE.Mesh(mountainGeometry, mountainMaterial);
        mountainMesh.castShadow = true; mountainMesh.receiveShadow = true;
        this.scene.add(mountainMesh); this.mountainMesh = mountainMesh;
    }

    calculatePathPoints() {
        this.pathPoints = []; const fieldCount = 73; const lastFieldIndex = fieldCount - 1;
        const mountainFootY = islandSurfaceY;
        for (let i = 0; i < fieldCount; i++) {
            const progress = i / (fieldCount - 1); let x, y, z; let onFlatLand = false;
            if (i === 0) { 
                x = BOARD_CONFIG.spiralStartRadius; z = 0; y = islandSurfaceY + 0.3; onFlatLand = true;
            } else if (i === lastFieldIndex) { 
                x = 0; y = mountainFootY + BOARD_CONFIG.mountainHeight + 0.2; z = BOARD_CONFIG.chamberSize/2 - 0.3; onFlatLand = false;
            } else if (i === lastFieldIndex - 1) { 
                x = 0; y = mountainFootY + BOARD_CONFIG.mountainHeight + 0.3; z = BOARD_CONFIG.chamberSize/2 + 0.8; onFlatLand = false;
            } else { 
                let radius;
                if (progress < 0.08) { radius = BOARD_CONFIG.spiralStartRadius * (1.0 - progress * 4.5); } 
                else if (progress < 0.85) {
                    const localProgress = (progress - 0.08) / 0.77; const easedProgress = Math.pow(localProgress, 0.9);
                    radius = THREE.MathUtils.lerp(BOARD_CONFIG.mountainBaseRadius - 0.6, BOARD_CONFIG.mountainTopRadius * 1.8, easedProgress);
                } else {
                    const gipfelProgress = (progress - 0.85) / 0.15; radius = BOARD_CONFIG.mountainTopRadius * (2.0 - gipfelProgress * 0.8);
                }
                const spiralProgress = Math.pow(progress, 0.9); const angle = spiralProgress * Math.PI * 2 * BOARD_CONFIG.spiralLoops;
                x = Math.cos(angle) * radius; z = Math.sin(angle) * radius;
                const distanceToCenter = Math.sqrt(x * x + z * z);
                if (distanceToCenter > BOARD_CONFIG.mountainBaseRadius - 0.6) { 
                    y = islandSurfaceY + 0.3; onFlatLand = true;
                } else { 
                    const mountainProgress = Math.max(0, Math.min(1, 1 - (distanceToCenter / (BOARD_CONFIG.mountainBaseRadius - 0.6))));
                    const smoothProgress = Math.pow(mountainProgress, 0.8);
                    y = mountainFootY + smoothProgress * BOARD_CONFIG.mountainHeight;
                    y += Math.sin(angle * 1.5) * 0.06; onFlatLand = false;
                }
            }
            this.pathPoints.push({ x, y, z, index: i, onFlatLand });
        }
        this.projectPathPointsOntoMountain();
    }
    
    projectPathPointsOntoMountain() {
        if (!this.mountainMesh || !this.pathPoints) return;
        for (let i = 0; i < this.pathPoints.length - 2; i++) { 
            const point = this.pathPoints[i];
            if (!point.onFlatLand) { 
                const raycaster = new THREE.Raycaster();
                const origin = new THREE.Vector3(point.x, 50, point.z); 
                const direction = new THREE.Vector3(0, -1, 0); 
                raycaster.set(origin, direction);
                const intersects = raycaster.intersectObject(this.mountainMesh, false);
                if (intersects.length > 0) {
                    point.y = Math.max(point.y, intersects[0].point.y + 0.1); 
                }
            }
        }
    }

    getTerrainHeightAt(x,z){
        const raycaster = new THREE.Raycaster(new THREE.Vector3(x, 50, z), new THREE.Vector3(0, -1, 0));
        const objectsToIntersect = [];
        if (this.mountainMesh) objectsToIntersect.push(this.mountainMesh);
        if (this.island) objectsToIntersect.push(this.island);
        const intersects = raycaster.intersectObjects(objectsToIntersect, false);
        if (intersects.length > 0) return intersects[0].point.y;
        return islandSurfaceY; 
    }

    getPathInfluence(x,z){
        let minDistance = Infinity;
        if (!this.pathPoints || this.pathPoints.length === 0) return 0;
        for (let i = 0; i < this.pathPoints.length; i++) {
            const point = this.pathPoints[i];
            const dx = x - point.x; const dz = z - point.z;
            minDistance = Math.min(minDistance, Math.sqrt(dx * dx + dz * dz));
        }
        const pathWidth = BOARD_CONFIG.pathWidth * 0.8; 
        if (minDistance < pathWidth) {
            return Math.pow(1 - (minDistance / pathWidth), 0.4); 
        }
        return 0;
    }

    getInterpolatedPathHeight(x,z){
        let closestDistance = Infinity; let closestIndex = -1;
        let secondClosestDistance = Infinity; let secondClosestIndex = -1;
        if (!this.pathPoints || this.pathPoints.length === 0) return islandSurfaceY;

        for (let i = 0; i < this.pathPoints.length; i++) {
            const point = this.pathPoints[i];
            const dx = x - point.x; const dz = z - point.z; const distance = Math.sqrt(dx * dx + dz * dz);
            if (distance < closestDistance) {
                secondClosestDistance = closestDistance; secondClosestIndex = closestIndex;
                closestDistance = distance; closestIndex = i;
            } else if (distance < secondClosestDistance) {
                secondClosestDistance = distance; secondClosestIndex = i;
            }
        }
        if (closestIndex === -1) return islandSurfaceY;
        if (closestDistance < 0.3) return this.pathPoints[closestIndex].y; 
        if (secondClosestIndex === -1) { 
            return this.pathPoints[closestIndex].y;
        }
        const point1 = this.pathPoints[closestIndex]; const point2 = this.pathPoints[secondClosestIndex];
        const dx1 = x - point1.x; const dz1 = z - point1.z; const dist1 = Math.sqrt(dx1*dx1 + dz1*dz1);
        const dx2 = x - point2.x; const dz2 = z - point2.z; const dist2 = Math.sqrt(dx2*dx2 + dz2*dz2);
        if (dist1 + dist2 === 0) return point1.y; 
        const weight1 = 1 - (dist1 / (dist1 + dist2)); 
        return point1.y * weight1 + point2.y * (1 - weight1);
    }

    createSpiralPath() { 
        console.log("[WiiPartyIsland] createSpiralPath() aufgerufen.");
        this.createGameFields(); 
    }
        
    createGameFields() { 
        if (!this.pathPoints || this.pathPoints.length === 0) { 
            console.error("[WiiPartyIsland] Path points not calculated for createGameFields."); return; 
        } 
        this.pathPoints.forEach((point, index) => { 
            let type = 'normal'; 
            if (index === 0) type = 'start'; 
            else if (index === this.pathPoints.length - 1) type = 'goal'; 
            else if (index % 8 === 0) type = 'bonus';
            else if (index % 12 === 0) type = 'minigame';
            else if (index % 15 === 0) type = 'chance';
            else if (index % 20 === 0) type = 'trap';
            const field = this.createGameField(point, type, index); 
            this.boardFields.push({ mesh: field, originalPathPoint: new THREE.Vector3(point.x, point.y, point.z), index: index, type: type }); 
            this.scene.add(field); 
        }); 
        console.log("[WiiPartyIsland] Game fields created:", this.boardFields.length); 
    }

    createGameField(point, type, index) { 
        const group = new THREE.Group(); const config = BOARD_CONFIG.fieldTypes[type];
        const fieldGeometry = new THREE.CylinderGeometry(BOARD_CONFIG.fieldRadius * 0.9, BOARD_CONFIG.fieldRadius * 1.0, BOARD_CONFIG.fieldHeight, 12); 
        const fieldMaterial = new THREE.MeshLambertMaterial({ color: config.color }); 
        const fieldMesh = new THREE.Mesh(fieldGeometry, fieldMaterial);
        fieldMesh.position.y = BOARD_CONFIG.fieldHeight / 2; fieldMesh.castShadow = true; fieldMesh.receiveShadow = true; group.add(fieldMesh);
        const ringGeometry = new THREE.TorusGeometry(BOARD_CONFIG.fieldRadius * 0.9, 0.03, 6, 16);
        const ringMaterial = new THREE.MeshLambertMaterial({ color: new THREE.Color(config.color).multiplyScalar(1.3) });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = -Math.PI / 2; ring.position.y = BOARD_CONFIG.fieldHeight + 0.01; group.add(ring);
        const baseGeometry = new THREE.CylinderGeometry(BOARD_CONFIG.fieldRadius * 1.1, BOARD_CONFIG.fieldRadius * 1.2, 0.1, 12);
        const baseMaterial = new THREE.MeshLambertMaterial({ color: new THREE.Color(config.color).multiplyScalar(0.7) });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = -0.05; base.castShadow = true; base.receiveShadow = true; group.add(base);
        group.position.set(point.x, point.y, point.z);
        group.userData = { fieldIndex: index, fieldType: type }; 
        return group; 
    }
    
    createVegetation() {
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2; const radius = 22 + Math.random() * 4;
            const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius;
            if (this.isPositionSafe(x, z, 2)) {
                const palm = this.createPalmTree(); palm.position.set(x, islandSurfaceY, z);
                palm.scale.setScalar(0.8 + Math.random() * 0.3); palm.rotation.y = Math.random() * Math.PI * 2; this.scene.add(palm);
            }
        }
        for (let i = 0; i < 12; i++) {
            const angle = Math.random() * Math.PI * 2; const radius = 16 + Math.random() * 8;
            const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius;
            if (this.isPositionSafe(x, z, 1.5)) {
                const bush = this.createBush(); const terrainY = this.getTerrainHeightAt(x, z);
                bush.position.set(x, terrainY, z); bush.scale.setScalar(0.5 + Math.random() * 0.4); this.scene.add(bush);
            }
        }
    }

    createPalmTree() {
        const palmGroup = new THREE.Group();
        const trunkGeometry = new THREE.CylinderGeometry(0.25, 0.35, 5.5, 8);
        const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 2.75; trunk.castShadow = true; trunk.receiveShadow = true; palmGroup.add(trunk);
        const leavesGroup = new THREE.Group(); leavesGroup.position.y = 5.5;
        for (let i = 0; i < 8; i++) {
            const leafGeometry = new THREE.PlaneGeometry(1.2, 2.8); leafGeometry.translate(0, 1.4, 0);
            const leafMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22, side: THREE.DoubleSide });
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.rotation.z = Math.PI / 8 + (Math.random() - 0.5) * 0.3;
            leaf.rotation.y = (i / 8) * Math.PI * 2; leaf.rotation.x = (Math.random() - 0.5) * 0.2;
            leaf.castShadow = true; leaf.receiveShadow = true; leavesGroup.add(leaf);
        }
        palmGroup.add(leavesGroup); return palmGroup;
    }

    createBush() {
        const bushGroup = new THREE.Group(); const colors = [0x2E7D32, 0x388E3C, 0x43A047, 0x4CAF50];
        for (let i = 0; i < 3; i++) {
            const bushElement = new THREE.Mesh(
                new THREE.SphereGeometry(0.15 + Math.random() * 0.12, 8, 8),
                new THREE.MeshLambertMaterial({ color: colors[Math.floor(Math.random() * colors.length)] })
            );
            bushElement.position.set((Math.random() - 0.5) * 0.6, 0.15 + Math.random() * 0.15, (Math.random() - 0.5) * 0.6);
            bushElement.scale.setScalar(0.7 + Math.random() * 0.6);
            bushElement.castShadow = true; bushElement.receiveShadow = true; bushGroup.add(bushElement);
        }
        return bushGroup;
    }
    
    createTreasureChamber() {
        const chamberGroup = new THREE.Group(); const chamberSize = BOARD_CONFIG.chamberSize;
        const chamberHeight = chamberSize * 0.65; const chamberWallThickness = 0.25;
        chamberGroup.position.set(0, islandSurfaceY + BOARD_CONFIG.mountainHeight, 0);
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xC9B037, shininess: 60, specular: 0xFFD700 });
        const floor = new THREE.Mesh(new THREE.BoxGeometry(chamberSize, chamberWallThickness, chamberSize), floorMaterial);
        floor.position.y = -chamberWallThickness/2; floor.receiveShadow = true; floor.castShadow = true; chamberGroup.add(floor);
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xFFF8DC, shininess: 30 });
        const roofMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520, shininess: 80, specular: 0xFFD700 });
        const roof = new THREE.Mesh(new THREE.BoxGeometry(chamberSize, chamberWallThickness, chamberSize), roofMaterial);
        roof.position.y = chamberHeight + chamberWallThickness/2; roof.castShadow = true; chamberGroup.add(roof);
        for (let i = 0; i < 4; i++) {
            const isEntrance = (i === 2);
            if (isEntrance) {
                const sideWallWidth = (chamberSize - chamberSize*0.35) / 2;
                const leftWall = new THREE.Mesh(new THREE.BoxGeometry(sideWallWidth, chamberHeight, chamberWallThickness), wallMaterial);
                leftWall.position.set(-chamberSize/2 + sideWallWidth/2, chamberHeight/2, chamberSize/2); leftWall.castShadow = true; leftWall.receiveShadow = true; chamberGroup.add(leftWall);
                const rightWall = new THREE.Mesh(new THREE.BoxGeometry(sideWallWidth, chamberHeight, chamberWallThickness), wallMaterial);
                rightWall.position.set(chamberSize/2 - sideWallWidth/2, chamberHeight/2, chamberSize/2); rightWall.castShadow = true; rightWall.receiveShadow = true; chamberGroup.add(rightWall);
                const topWall = new THREE.Mesh(new THREE.BoxGeometry(chamberSize*0.35, chamberHeight*0.25, chamberWallThickness), wallMaterial);
                topWall.position.set(0, chamberHeight - chamberHeight*0.125, chamberSize/2); topWall.castShadow = true; topWall.receiveShadow = true; chamberGroup.add(topWall);
                const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, shininess: 40, specular: 0x654321 });
                const door = new THREE.Mesh(new THREE.BoxGeometry(chamberSize*0.3, chamberHeight*0.65, chamberWallThickness/2), doorMaterial);
                door.position.set(0, chamberHeight*0.325, chamberSize/2); door.castShadow = true; door.receiveShadow = true; chamberGroup.add(door); this.chamberDoor = door;
                const handleMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520, shininess: 100, specular: 0xFFD700 });
                const handle = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), handleMaterial);
                handle.position.set(-chamberSize*0.08, 0, chamberWallThickness/2); door.add(handle);
            } else {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(chamberSize, chamberHeight, chamberWallThickness), wallMaterial);
                if (i === 0) { wall.position.set(0, chamberHeight/2, -chamberSize/2); } 
                else if (i === 1) { wall.position.set(chamberSize/2, chamberHeight/2, 0); wall.rotation.y = Math.PI / 2; } 
                else if (i === 3) { wall.position.set(-chamberSize/2, chamberHeight/2, 0); wall.rotation.y = Math.PI / 2; }
                wall.castShadow = true; wall.receiveShadow = true; chamberGroup.add(wall);
            }
        }
        this.createTreasure(chamberGroup, chamberSize); this.decorateChamber(chamberGroup, chamberSize);
        this.scene.add(chamberGroup); this.treasureChamber = chamberGroup;
    }

    createTreasure(chamberGroup, chamberSize){ /* ... (dein vollständiger Code für createTreasure) ... */ }
    decorateChamber(chamberGroup, chamberSize){ /* ... (dein vollständiger Code für decorateChamber) ... */ }
    createEnvironmentalDetails() { this.createClouds(); this.createWildlife(); }
    createClouds() { /* ... (dein vollständiger Code für createClouds) ... */ }
    createWildlife() { /* ... (dein vollständiger Code für createWildlife) ... */ }
    createBird() { /* ... (dein vollständiger Code für createBird) ... */ }
    isPositionSafe(x,z,md) { /* ... (dein vollständiger Code für isPositionSafe) ... */ return true; }
    
    setupEventListeners() {
        console.log("[WiiPartyIsland] setupEventListeners aufgerufen. typeof this.boundUpdateCanvasSize:", typeof this.boundUpdateCanvasSize);
        window.addEventListener('resize', this.boundUpdateCanvasSize); 
        
        document.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'm') {
                GAME_STATE.freeCameraMode = !GAME_STATE.freeCameraMode;
                this.controls.enabled = GAME_STATE.freeCameraMode;
                this.showStatusMessage(GAME_STATE.freeCameraMode ? 'Freie Kamera aktiviert' : 'Freie Kamera deaktiviert');
                if (!GAME_STATE.freeCameraMode && teams && teams.length > 0) {
                    GAME_STATE.isAnimating = false; GAME_STATE.isAnimatingCamera = false; GAME_STATE.playerTurnInProgress = false;
                    this.stopCameraFollow(); 
                    this.prepareNextPlayerTurn(false);
                }
            } else if (event.key.toLowerCase() === 'f') { this.toggleFullscreen(); }
        });
        const rollDiceButton = document.getElementById('roll-dice');
        if (rollDiceButton) {
            rollDiceButton.addEventListener('click', this.rollDice); 
        }
    }
    
    showStatusMessage(message) { const existingMessage = document.querySelector('.status-message'); if (existingMessage) existingMessage.remove(); const statusDiv = document.createElement('div'); statusDiv.className = 'status-message'; statusDiv.textContent = message; document.body.appendChild(statusDiv); setTimeout(() => { statusDiv.remove(); }, 3000); }
    getCurrentTeam() { if (teams && teams.length > 0) return teams[GAME_STATE.currentTeamIndex]; return null; }
    prepareNextPlayerTurn(immediate = false) { if (!this.getCurrentTeam()) return; console.log("Nächster Zug für:", this.getCurrentTeam().name); GAME_STATE.playerTurnInProgress = false; this.updateTeamDisplay(); /* Vollständige Logik hier */ }
    nextTeam() { if (!teams || teams.length === 0) return; GAME_STATE.currentTeamIndex = (GAME_STATE.currentTeamIndex + 1) % teams.length; this.updateTeamDisplay(); if (!GAME_STATE.freeCameraMode) { this.prepareNextPlayerTurn(false); } }
    updateTeamDisplay() { const currentTeam = this.getCurrentTeam(); if (currentTeam) { const el = document.getElementById('current-team'); if(el) el.textContent = currentTeam.name; document.querySelectorAll('.team-badge').forEach(badge => badge.classList.remove('active-team')); const teamBadges = document.querySelectorAll('.team-badge'); if (teamBadges[GAME_STATE.currentTeamIndex]) { teamBadges[GAME_STATE.currentTeamIndex].classList.add('active-team'); } } else { const el = document.getElementById('current-team'); if(el) el.textContent = '-';}}
    focusCameraOnCurrentTeam(immediate = false, callback) { if (callback) callback(); /* Vollständige Logik hier */ }
    startCameraFollow(character) { /* Vollständige Logik hier */ }
    stopCameraFollow() { /* Vollständige Logik hier */ }
    updateCameraFollow(immediate = false) { /* Vollständige Logik hier */ }
    animateCameraToPosition(targetCamPos, targetLookAtPos, duration = 1200, callback) { if (callback) callback(); /* Vollständige Logik hier */ }
    easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
    createDiceFaceTexture(number) { const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=256; const ctx = canvas.getContext('2d'); const gradient = ctx.createLinearGradient(0,0,256,256); gradient.addColorStop(0,'#fff'); gradient.addColorStop(0.5,'#f8f8f8'); gradient.addColorStop(1,'#eee'); ctx.fillStyle=gradient; ctx.fillRect(0,0,256,256); ctx.strokeStyle='#ccc'; ctx.lineWidth=256/20; ctx.strokeRect(ctx.lineWidth/2,ctx.lineWidth/2,256-ctx.lineWidth,256-ctx.lineWidth); ctx.strokeStyle='#e0e0e0'; ctx.lineWidth=256/32; ctx.strokeRect(256/16,256/16,256-256/8,256-256/8); ctx.fillStyle='#2c2c2c'; const dotRadius=256/12; const padding=256/4.5; const positions={1:[[256/2,256/2]],2:[[padding,padding],[256-padding,256-padding]],3:[[padding,padding],[256/2,256/2],[256-padding,256-padding]],4:[[padding,padding],[256-padding,padding],[padding,256-padding],[256-padding,256-padding]],5:[[padding,padding],[256-padding,padding],[256/2,256/2],[padding,256-padding],[256-padding,256-padding]],6:[[padding,padding],[256-padding,padding],[padding,256/2],[256-padding,256/2],[padding,256-padding],[256-padding,256-padding]],}; if(positions[number]){positions[number].forEach(pos=>{ctx.fillStyle='#1a1a1a';ctx.beginPath();ctx.arc(pos[0]+2,pos[1]+2,dotRadius,0,Math.PI*2);ctx.fill();const dotGradient=ctx.createRadialGradient(pos[0]-dotRadius/3,pos[1]-dotRadius/3,0,pos[0],pos[1],dotRadius);dotGradient.addColorStop(0,'#444');dotGradient.addColorStop(0.7,'#2c2c2c');dotGradient.addColorStop(1,'#1a1a1a');ctx.fillStyle=dotGradient;ctx.beginPath();ctx.arc(pos[0],pos[1],dotRadius,0,Math.PI*2);ctx.fill();ctx.fillStyle='#666';ctx.beginPath();ctx.arc(pos[0]-dotRadius/4,pos[1]-dotRadius/4,dotRadius/4,0,Math.PI*2);ctx.fill();});} const texture=new THREE.CanvasTexture(canvas);texture.needsUpdate=true;return texture;}
    createInteractiveDice() { const diceSize=0.5; const geometry=new THREE.BoxGeometry(diceSize,diceSize,diceSize); geometry.parameters.widthSegments=2; geometry.parameters.heightSegments=2; geometry.parameters.depthSegments=2; const materials=[]; for(let i=1;i<=6;i++){materials.push(new THREE.MeshPhongMaterial({map:this.createDiceFaceTexture(i),shininess:120,specular:0xffffff,bumpScale:0.02}));} const orderedMaterials=[materials[0],materials[5],materials[1],materials[4],materials[2],materials[3]]; this.interactiveDice=new THREE.Mesh(geometry,orderedMaterials); this.interactiveDice.castShadow=true; this.interactiveDice.receiveShadow=true; this.interactiveDice.visible=false; this.interactiveDice.userData.isDice=true; this.scene.add(this.interactiveDice); this.createDiceResultNumber(); }
    createDiceResultNumber() { /* Vollständige Logik hier */ }
    animateCharacterTurn(character, targetLookAtPosition, callback, duration = 600) { if (callback) callback(); /* Vollständige Logik hier */ }
    rollDice() { if (GAME_STATE.isAnimating || GAME_STATE.isDiceRolling || !this.getCurrentTeam()) return; GAME_STATE.isAnimating = true; GAME_STATE.isDiceRolling = true; const diceResult = Math.floor(Math.random() * 6) + 1; console.log("Würfel:", diceResult); this.showDiceResult(diceResult); setTimeout(() => { this.hideDiceResult(); const currentTeam = this.getCurrentTeam(); const mii = this.miiCharacters[currentTeam.id]; this.actuallyMoveCharacter(currentTeam, mii, diceResult, currentTeam.position); GAME_STATE.isDiceRolling = false; }, 1000); }
    showDiceResult(result) { const display = document.getElementById('dice-result-display'); const number = display.querySelector('.dice-result-number'); if (display && number) { number.textContent = result; display.classList.add('show'); } }
    hideDiceResult() { const display = document.getElementById('dice-result-display'); if (display) { display.classList.remove('show'); } }
    animateInteractiveDiceRoll(callback) { if (callback) callback(Math.floor(Math.random() * 6) + 1); /* Vollständige Logik hier */ }
    actuallyMoveCharacter(currentTeam, mii, diceRoll, startPositionIndex) { console.log(`Bewege ${currentTeam.name} um ${diceRoll} von ${startPositionIndex}`); const endPositionIndex = Math.min(startPositionIndex + diceRoll, this.boardFields.length - 1); currentTeam.position = endPositionIndex; if (this.boardFields[endPositionIndex] && this.boardFields[endPositionIndex].mesh && mii) { const fieldPos = this.boardFields[endPositionIndex].mesh.position; mii.position.set(fieldPos.x, fieldPos.y + BOARD_CONFIG.characterElevation, fieldPos.z); } this.handleMovementCompletion(currentTeam, mii, endPositionIndex); }
    handleMovementCompletion(currentTeam, mii, finalPositionIndex) { console.log(`${currentTeam.name} ist auf Feld ${finalPositionIndex}`); this.updateTeamBadge(GAME_STATE.currentTeamIndex, finalPositionIndex); this.saveTeamPosition(currentTeam.id, finalPositionIndex); GAME_STATE.isCharacterMoving = false; GAME_STATE.isAnimating = false; this.nextTeam(); }
    showFieldEffect(position, color) { /* Vollständige Logik hier */ }
    animateCharacterMove(character, targetPosition, callback, totalDuration = 400) { if (callback) callback(); /* Vollständige Logik hier */ }
    animateCharacterAlongPath(character, pathCurve, onComplete) { if (onComplete) onComplete(); /* Vollständige Logik hier */ }
    openTreasureChamberDoor(callback) { if (callback) callback(); /* Vollständige Logik hier */ }
    moveCharacterIntoChamber(character, callback) { if (callback) callback(); /* Vollständige Logik hier */ }
    animateVictory(character, team) { /* Vollständige Logik hier */ }
    showVictoryEffect() { /* Vollständige Logik hier */ }
    updateTeamBadge(teamIndex, position) { const teamBadges = document.querySelectorAll('.team-badge'); if (teamIndex < teamBadges.length) { const positionSpan = teamBadges[teamIndex].querySelector('.team-position'); if (positionSpan) positionSpan.textContent = `Position: ${position}`; } }
    saveTeamPosition(teamId, position) { fetch('/api/update-position', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ team_id: teamId, position: position }) }); }
    toggleFullscreen() { console.log("Toggle Fullscreen"); /* Vollständige Logik hier */ }
    updateCharacterAnimations(time) { /* Vollständige Logik hier */ }

    animate() {
        requestAnimationFrame(this.animate); 
        const time = Date.now() * 0.001;

        if (this.water && this.water.userData && this.water.userData.animation) { 
            this.water.userData.animation(time); 
        }
        if (GAME_STATE.freeCameraMode && this.controls) {
            this.controls.update();
        }
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }
} // Ende der WiiPartyIsland Klasse

document.addEventListener('DOMContentLoaded', function() {
    console.log("[DOMContentLoaded] Event gefeuert.");
    const isAdminFromTemplate = {{ is_admin|tojson }};
    console.log("[DOMContentLoaded] Teams-Daten aus Template:", JSON.parse(JSON.stringify(teams)));
    console.log("[DOMContentLoaded] is_admin aus Template:", isAdminFromTemplate);
    
    const canvasElement = document.getElementById('game-canvas');
    const canvasContainer = document.getElementById('game-canvas-container');

    if (canvasElement && canvasContainer) {
        if (teams && teams.length > 0) { 
            console.log("[DOMContentLoaded] Teams vorhanden, initialisiere WiiPartyIsland.");
            try {
                window.gameBoard = new WiiPartyIsland('game-canvas');
            } catch (e) {
                console.error("[DOMContentLoaded] Kritischer Fehler bei 'new WiiPartyIsland':", e);
                canvasContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Kritischer Fehler beim Erstellen des Spielbretts. Details in der Konsole.</p>";
            }
        } else {
            console.log("[DOMContentLoaded] Keine Teams vorhanden.");
            if (isAdminFromTemplate) {
                canvasContainer.innerHTML = "<p style='color:#333; text-align:center; padding-top: 50px; font-size:1.2em;'>Noch keine Teams angelegt. Bitte im <a href='{{ url_for('admin.admin_dashboard') }}'>Admin Dashboard</a> Teams erstellen, um das Spielbrett zu sehen.</p>";
            } else {
                 canvasContainer.innerHTML = "<p style='color:#333; text-align:center; padding-top: 50px; font-size:1.2em;'>Warte auf Spieler oder starte ein neues Spiel. Das Spielbrett wird angezeigt, sobald Teams vorhanden sind.</p>";
            }
        }
    } else {
        console.error("[DOMContentLoaded] Canvas-Element ('game-canvas') oder Container ('game-canvas-container') nicht gefunden.");
        if(canvasContainer) { 
            canvasContainer.innerHTML = "<p style='color:red; text-align:center; padding-top: 50px;'>Fehler: Canvas-Element für Spielbrett nicht gefunden.</p>";
        } else if (document.body) { 
            document.body.insertAdjacentHTML('afterbegin', "<p style='color:red; text-align:center; padding: 50px;'>Fehler: Wichtige Seitenelemente für das Spielbrett fehlen.</p>");
        }
    }
});
</script>

<style>
/* CSS bleibt gleich */
.game-container {
    position: relative;
    width: 100%;
    height: 88vh; 
    margin: 0 auto;
    background: radial-gradient(ellipse at center, #B3E5FC 0%, #4FC3F7 50%, #0288D1 100%);
    border-radius: 25px;
    overflow: hidden;
    box-shadow: 
        0 15px 50px rgba(0, 0, 0, 0.25),
        inset 0 2px 8px rgba(255, 255, 255, 0.3);
}

#game-canvas-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 25px; 
    background: linear-gradient(to bottom, #B3E5FC 0%, #4FC3F7 40%, #0288D1 100%); 
}

#game-canvas {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab; 
    border-radius: 25px; 
}

#game-canvas:active {
    cursor: grabbing; 
}

.game-overlay {
    position: absolute;
    top: 18px;
    left: 18px;
    z-index: 100; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
    max-width: 400px; 
    pointer-events: none; 
}

.game-overlay > div {
    pointer-events: auto; 
}

.current-team-display {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 255, 0.95));
    border-radius: 15px;
    padding: 15px 25px;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.15),
        0 2px 10px rgba(0, 0, 0, 0.1);
    font-weight: bold;
    color: #1565C0; 
    backdrop-filter: blur(12px); 
    border: 2px solid rgba(255, 255, 255, 0.5);
}

.current-team-display h4 {
    margin: 0;
    font-size: 1.2rem;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.team-status {
    display: flex;
    gap: 12px;
    flex-wrap: wrap; 
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(245, 250, 255, 0.9));
    padding: 18px;
    border-radius: 15px;
    box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.15),
        0 2px 10px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(12px);
    border: 2px solid rgba(255, 255, 255, 0.5);
}

.team-badge {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px 15px;
    border-radius: 12px;
    color: white;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
    font-weight: 700;
    font-size: 0.9rem;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    transform: scale(1);
    box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.2),
        inset 0 1px 3px rgba(255, 255, 255, 0.3);
    animation: gentleFloat 5s ease-in-out infinite;
    border: 2px solid rgba(255, 255, 255, 0.4);
}

.team-badge:nth-child(2) { animation-delay: -1s; }
.team-badge:nth-child(3) { animation-delay: -2s; }
.team-badge:nth-child(4) { animation-delay: -3s; }

@keyframes gentleFloat {
    0% { transform: translateY(0px) scale(1); }
    50% { transform: translateY(-6px) scale(1.02); }
    100% { transform: translateY(0px) scale(1); }
}

.team-badge:hover {
    transform: scale(1.08) translateY(-3px);
    box-shadow: 
        0 12px 20px rgba(0, 0, 0, 0.35),
        inset 0 2px 5px rgba(255, 255, 255, 0.4);
}

.team-badge.active-team {
    border: 3px solid #FFD700; 
    transform: scale(1.15) translateY(-4px);
    box-shadow: 
        0 0 25px rgba(255, 215, 0, 0.7), 
        0 12px 25px rgba(0, 0, 0, 0.4),
        inset 0 2px 8px rgba(255, 255, 255, 0.5);
    animation: activeGlow 2.5s infinite, gentleFloat 5s ease-in-out infinite;
}

@keyframes activeGlow {
    0% { 
        box-shadow: 
            0 0 25px rgba(255, 215, 0, 0.7),
            0 12px 25px rgba(0, 0, 0, 0.4),
            inset 0 2px 8px rgba(255, 255, 255, 0.5);
    }
    50% { 
        box-shadow: 
            0 0 35px rgba(255, 215, 0, 0.9),
            0 15px 30px rgba(0, 0, 0, 0.5),
            inset 0 3px 12px rgba(255, 255, 255, 0.6);
    }
    100% { 
        box-shadow: 
            0 0 25px rgba(255, 215, 0, 0.7),
            0 12px 25px rgba(0, 0, 0, 0.4),
            inset 0 2px 8px rgba(255, 255, 255, 0.5);
    }
}

.team-name { font-size: 0.9rem; letter-spacing: 0.4px; }
.team-position { font-size: 0.8rem; opacity: 0.9; margin-top: 2px; }

.admin-controls {
    display: flex; align-items: center; gap: 18px;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(240, 245, 255, 0.92));
    padding: 18px; border-radius: 15px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15), 0 2px 10px rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(12px); border: 2px solid rgba(255, 255, 255, 0.5);
}

.dice-result-display {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0); 
    background: linear-gradient(135deg, rgba(255, 215, 0, 0.98), rgba(255, 193, 7, 0.95)); 
    border-radius: 50%; width: 140px; height: 140px;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    box-shadow: 0 0 50px rgba(255, 215, 0, 0.9), 0 15px 40px rgba(0, 0, 0, 0.4), inset 0 3px 15px rgba(255, 255, 255, 0.5);
    z-index: 200; opacity: 0;
    transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); 
    border: 3px solid rgba(255, 255, 255, 0.8);
}
.dice-result-display.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
.dice-result-number { font-size: 4.5rem; font-weight: bold; color: #1A237E; text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3); line-height: 1; }
.dice-result-text { font-size: 1.1rem; color: #3F51B5; font-weight: 700; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); }

.btn-primary {
    background: linear-gradient(135deg, #1976D2, #0D47A1); border-radius: 15px; font-weight: 700;
    padding: 15px 30px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15), inset 0 1px 3px rgba(255, 255, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.3); letter-spacing: 0.6px;
    pointer-events: auto; color: white; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}
.btn-primary:hover {
    transform: translateY(-4px); 
    box-shadow: 0 12px 25px rgba(0, 0, 0, 0.25), inset 0 2px 5px rgba(255, 255, 255, 0.4);
    background: linear-gradient(135deg, #0D47A1, #01579B);
}
.btn-primary:active { transform: translateY(-2px); }
.btn-primary:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

.help-text {
    font-size: 0.95rem; color: #37474F; background: rgba(255, 255, 255, 0.9);
    padding: 8px 12px; border-radius: 8px; backdrop-filter: blur(6px);
    pointer-events: auto; border: 1px solid rgba(255,255,255,0.5); box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
kbd {
    background: linear-gradient(145deg, #263238, #37474F); color: white;
    padding: 5px 10px; border-radius: 8px; font-family: 'Segoe UI', monospace;
    font-size: 0.9em; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3), inset 0 1px 2px rgba(255, 255, 255, 0.2);
    border: 1px solid #1A252F;
}
.status-message {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(26, 35, 47, 0.96); color: white; padding: 22px 40px;
    border-radius: 15px; font-size: 1.3rem; font-weight: 700; z-index: 1000;
    backdrop-filter: blur(12px); border: 2px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5), inset 0 1px 3px rgba(255, 255, 255, 0.1);
    animation: statusMessageAnim 3s ease-in-out forwards; text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
}
@keyframes statusMessageAnim {
    0% { opacity: 0; transform: translate(-50%, -65%) scale(0.9); }
    12% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
    18% { transform: translate(-50%, -50%) scale(1); }
    82% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -35%) scale(0.9); }
}
@media (max-width: 768px) {
    .game-overlay { max-width: 320px; gap: 12px; top: 12px; left: 12px; }
    .team-status { flex-direction: column; padding: 15px; }
    .team-badge { flex-direction: row; justify-content: space-between; width: 100%; padding: 8px 12px; }
    .admin-controls { flex-wrap: wrap; justify-content: center; gap: 12px; }
    .dice-result-display { width: 120px; height: 120px; }
    .dice-result-number { font-size: 3.5rem; }
    .dice-result-text { font-size: 1rem; }
    .game-container { height: 82vh; border-radius: 20px; }
    #game-canvas-container { border-radius: 20px; }
}
@keyframes shimmer { 0% { background-position: -200px 0; } 100% { background-position: 200px 0; } }
.team-badge::before {
    content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
    transition: left 0.5s;
}
.team-badge:hover::before { left: 100%; }

</style>
{% endblock %}
